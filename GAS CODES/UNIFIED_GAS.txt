/**
 * Unified GAS entrypoint for Booking / Jobcard / Quotation / Minor Sales / Stocks / Branches / Vehicle Catalog.
 * Deploy once, optionally set MASTER_SPREADSHEET_ID to override per-module sheet IDs, and pass ?module=<name> in calls.
 * Example: https://script.google.com/.../exec?module=jobcard&action=list
 */
const MASTER_SPREADSHEET_ID = '1bJy5qk7UEnGoiHYoQNd__r3CRabavMR6HiWZ4bxGRYQ'; // Optional override that controls all modules
const __MODULES__ = {};
const MASTER_OVERRIDE_SPREADSHEET_ID = MASTER_SPREADSHEET_ID ? MASTER_SPREADSHEET_ID : '';

function resolveSpreadsheetId(localId) {
  if (MASTER_OVERRIDE_SPREADSHEET_ID) return MASTER_OVERRIDE_SPREADSHEET_ID;
  if (localId && typeof localId === 'string') {
    return localId.trim();
  }
  return '';
}

function openSpreadsheet(localId) {
  const target = resolveSpreadsheetId(localId);
  if (target) return SpreadsheetApp.openById(target);
  return SpreadsheetApp.getActiveSpreadsheet();
}

function ensureSheetWithHeader(ss, sheetName, headers = [], options = {}) {
  const { allowFallbackFirstSheet = true } = options || {};
  let sh = sheetName ? ss.getSheetByName(sheetName) : null;
  if (!sh && sheetName) {
    try {
      sh = ss.insertSheet(sheetName);
    } catch (err) {
      sh = null;
    }
  }
  if (!sh && allowFallbackFirstSheet) {
    const sheets = ss.getSheets();
    if (sheets.length) {
      sh = sheets[0];
    } else {
      sh = ss.insertSheet(sheetName || 'Sheet1');
    }
  }
  if (!sh) return null;
  if (Array.isArray(headers) && headers.length) {
    const width = Math.max(sh.getLastColumn(), headers.length);
    const firstRow = sh.getRange(1, 1, 1, width).getValues()[0] || [];
    const hasValues = firstRow.some((value) => String(value || '').trim().length > 0);
    if (!hasValues) {
      if (sh.getMaxColumns() < headers.length) {
        sh.insertColumnsAfter(sh.getMaxColumns(), headers.length - sh.getMaxColumns());
      }
      sh.getRange(1, 1, 1, headers.length).setValues([headers]);
      sh.setFrozenRows(1);
    }
  }
  return sh;
}

(() => {
// ====== BOOKING =====
function doPost(e) {
  try {
    const ct = (e && e.postData && e.postData.type) || '';
    const params = (e && e.parameter) || {};

    // Multipart upload (FormData)
    if (/multipart\/form-data/i.test(ct)) {
      if (BOOKING_WRITE_SECRET && params.secret !== BOOKING_WRITE_SECRET) {
        return json_({ ok: false, error: 'unauthorized' });
      }
      const action = String(params.action || '').toLowerCase();
      if (action === 'upload') {
        return json_(uploadFile_(e));
      }
      return json_({ ok: false, error: 'bad_multipart_action' });
    }

    // JSON body
    const raw = (e && e.postData && e.postData.contents) || '{}';
    const body = parseJson_(raw, {});
    if (BOOKING_WRITE_SECRET && body.secret !== BOOKING_WRITE_SECRET) {
      return json_({ success: false, error: 'unauthorized' });
    }

    let act = String(body.action || '').toLowerCase();

    // Defaulting: only force update if bookingId or editMobile present.
    // Else if it looks like a create (customer + vehicle), create.
    if (!act) {
      if (body.bookingId || body.editMobile) {
        act = 'update';
      } else if (looksLikeCreate_(body)) {
        act = 'create';
      }
    }

    if (act === 'upload_base64') {
      return json_(uploadBase64_(body));
    }

    if (act === 'update') {
      // Route dashboard ‚Äúpatch‚Äù updates (Actions on Bookings page)
      if (body.patch && (body.bookingId || body.mobile || body.editMobile)) {
        const bookingId = String(body.bookingId || '').trim();
        const mobile = String(body.mobile || body.editMobile || '').replace(/\D/g, '').slice(-10);
        return json_(updateBooking_(bookingId, body.patch || {}, mobile));
      }
      // Otherwise treat as full-body update (payments, fields, optional file)
      return json_(updateExistingByBody_(body));
    }

    if (act === 'remark') {
      const bookingId = String(body.bookingId || '').trim();
      const level = String(body.level || '').toLowerCase(); // ok|warning|alert
      const text = String(body.text || '').trim();
      const by = String(body.by || '').trim();
      return json_(updateRemark_(bookingId, level, text, by));
    }

    if (act === 'attach') {
      const bookingId = String(body.bookingId || '').trim();
      const mobile = String(body.mobile || '').replace(/\D/g, '').slice(-10);
      const file = {
        name: body.name || '',
        url: body.url || '',
        fileId: body.fileId || ''
      };
      const type = String(body.type || '');
      const append = false; // Force replacement; do not accumulate comma-separated links
      const ts = new Date().toISOString();
      return json_(attachDocument_(bookingId, mobile, file, type, append, ts));
    }

    if (act === 'create' || looksLikeCreate_(body)) {
      return json_(createOrUpdateBooking_(body));
    }

    return json_({ success: false, error: 'invalid_action_or_payload' });
  } catch (err) {
    return json_({ success: false, error: String(err) });
  }
}

function doGet(e) {
  try {
    const p = (e && e.parameter) || {};
    if (BOOKING_READ_SECRET && p.secret !== BOOKING_READ_SECRET) return json_({ ok: false, error: 'unauthorized' });
    const action = String(p.action || 'list').toLowerCase();

    if (action === 'search') {
      const mode = String(p.mode || '').toLowerCase(); // booking|mobile
      const query = String(p.query || '').trim();
      return json_(searchBookings_(mode, query));
    }

    if (action === 'check_duplicate') {
      const mobile = String(p.mobile || '').replace(/\D/g, '').slice(-10);
      const bookingId = String(p.bookingId || '').trim();
      return json_(checkDuplicate_(mobile, bookingId));
    }

    return json_(listBookings_(p));
  } catch (err) {
    return json_({ ok: false, error: String(err) });
  }
}

// ===================== CONFIG / BOOKING_HEADERS =====================

const BOOKING_SHEET_NAME = 'Bookings';
const BOOKING_SPREADSHEET_ID = ''; // leave '' if bound to spreadsheet
const BOOKING_DRIVE_FOLDER_ID = '1VMnnv-2zYwX4j3k4JSC_Qc6Il7xYaRsT';

const BOOKING_READ_SECRET = '';  // optional
const BOOKING_WRITE_SECRET = ''; // optional

const BOOKING_MAX_FILE_BYTES = 10 * 1024 * 1024; // <= 5 MB
const BOOKING_ALLOWED_MIME = 'application/pdf';

const BOOKING_HEADERS = [
  'Booking ID', 'Submitted At', 'Branch', 'Executive', 'Customer Name', 'Mobile Number',
  'Company', 'Model', 'Variant', 'Color', 'Chassis Number',
  'Chassis Availability', 'Availability Branch',
  'Purchase Mode', 'Financier', 'RTO Office', 'Address',
  'Address Proof Mode', 'Address Proof Types', 'Booking Amount',
  'File Name', 'File URL', 'File Type', 'File Size',
  'Status', 'Notes',
  'Invoice Status', 'Invoice File URL',
  'Insurance Status', 'Insurance File URL',
  'RTO Status', 'Vehicle No',
  'RemarkLevel', 'RemarkText',
  'Raw Payload'
];

// üî¥ Master DailyCollections spreadsheet (one for all modules)
const BOOKING_DC_MASTER_SPREADSHEET_ID = MASTER_SPREADSHEET_ID;

// ===================== CREATE / UPDATE =====================

function looksLikeCreate_(data) {
  const hasCustomer = !!(data.customerName || data.name);
  const hasMobile = !!String(data.mobileNumber || data.mobile || '').replace(/\D/g, '').slice(-10);
  const v = data.vehicle || {};
  const hasVehicle = !!(data.company || data.model || data.variant || v.company || v.model || v.variant);
  return (hasCustomer || hasMobile) && hasVehicle;
}

function createOrUpdateBooking_(data) {
  const mobile = String(data.mobileNumber || data.mobile || '').replace(/\D/g, '').slice(-10);
  const bookingId = String(data.bookingId || '').trim();
  const existingRow = findExistingBooking_(mobile, bookingId);
  if (existingRow.found) return updateExistingBooking_(existingRow, data);
  return createNewBooking_(data);
}

function updateExistingByBody_(data) {
  const mobile = String(data.editMobile || data.mobileNumber || data.mobile || '').replace(/\D/g, '').slice(-10);
  const bookingId = String(data.bookingId || '').trim();
  const existing = findExistingBooking_(mobile, bookingId);
  if (!existing.found) return { success: false, error: 'not_found' };
  return updateExistingBooking_(existing, data);
}

function findExistingBooking_(mobile, bookingId) {
  const sh = getSheet_();
  const headers = sh.getRange(1, 1, 1, BOOKING_HEADERS.length).getValues()[0];
  const last = sh.getLastRow();
  if (last < 2) return { found: false, rowIndex: -1, rowData: null };

  const idCol = headers.indexOf('Booking ID') + 1;
  const mobileCol = headers.indexOf('Mobile Number') + 1;
  const range = sh.getRange(2, 1, last - 1, BOOKING_HEADERS.length).getValues();

  if (bookingId && idCol > 0) {
    for (let i = 0; i < range.length; i++) {
      if (String(range[i][idCol - 1]) === bookingId) {
        return { found: true, rowIndex: i + 2, rowData: range[i], matchType: 'bookingId' };
      }
    }
  }

  if (mobile && mobileCol > 0) {
    for (let i = range.length - 1; i >= 0; i--) {
      const cellMobile = String(range[i][mobileCol - 1] || '').replace(/\D/g, '').slice(-10);
      if (cellMobile && cellMobile === mobile) {
        return { found: true, rowIndex: i + 2, rowData: range[i], matchType: 'mobile' };
      }
    }
  }

  return { found: false, rowIndex: -1, rowData: null };
}

function updateExistingBooking_(existing, data) {
  const sh = getSheet_();
  const headers = sh.getRange(1, 1, 1, BOOKING_HEADERS.length).getValues()[0];

  const cells = headers.map((_, i) => existing.rowData[i] || '');

  const v = data.vehicle || {};
  const company = data.company || v.company || '';
  const model = data.model || data.bikeModel || v.model || '';
  const variant = data.variant || v.variant || '';
  const color = data.color || v.color || '';
  const chassisNo = data.chassisNo || v.chassisNo || '';
  const availability = String(data.availability || v.availability || '');
  const availabilityBranch = (v && v.availabilityInfo && v.availabilityInfo.branch) ? v.availabilityInfo.branch : '';

  const branch = data.branch || '';
  const executive = data.executive || '';
  const customerName = data.customerName || data.name || '';
  const mobileNumber = data.mobileNumber || data.mobile || '';
  const rtoOffice = data.rtoOffice || '';
  const purchaseMode = data.purchaseMode || data.purchaseType || '';
  const financier = data.financier || data.nohpFinancier || '';
  const address = data.address || '';
  const addressProofMode = data.addressProofMode || data.addressProof || '';
  const addressProofTypes = Array.isArray(data.addressProofTypes) ? data.addressProofTypes.join(', ') : (data.addressProofTypes || '');

  // Booking Amount from payments[] if not provided
  var payments = Array.isArray(data.payments) ? data.payments : [];
  var bookingAmount = data.bookingAmount || '';
  if ((!bookingAmount || String(bookingAmount).trim() === '') && payments.length) {
    try {
      var sum = 0;
      for (var i = 0; i < payments.length; i++) {
        var a = Number(payments[i] && payments[i].amount ? payments[i].amount : 0) || 0;
        sum += a;
      }
      bookingAmount = String(sum);
    } catch (e) { /* ignore */ }
  }

  // Merge Raw Payload (strip base64, cap big strings)
  let payload = {};
  try { payload = JSON.parse(String(cells[idx(headers, 'Raw Payload')] || '{}')); } catch (e) { payload = {}; }
  payload.branch = branch || payload.branch || '';
  payload.executive = executive || payload.executive || '';
  payload.customerName = customerName || payload.customerName || '';
  payload.mobileNumber = mobileNumber || payload.mobileNumber || '';
  payload.vehicle = payload.vehicle || {};
  payload.vehicle.company = company || payload.vehicle.company || '';
  payload.vehicle.model = model || payload.vehicle.model || '';
  payload.vehicle.variant = variant || payload.vehicle.variant || '';
  payload.vehicle.color = color || payload.vehicle.color || '';
  payload.vehicle.chassisNo = chassisNo || payload.vehicle.chassisNo || '';
  if (addressProofMode) payload.addressProofMode = addressProofMode;
  if (Array.isArray(data.addressProofTypes)) payload.addressProofTypes = data.addressProofTypes;
  if (payments && payments.length) payload.payments = payments;
  if (bookingAmount) payload.bookingAmount = bookingAmount;

  // Optional file replace (ALWAYS keep only latest link)
  const incomingFile =
    data.file ||
    (Array.isArray(data.files) && data.files[0]) ||
    (Array.isArray(data.addressProofFiles) && data.addressProofFiles[0]) ||
    null;

  const savedFile = saveOneFileToDrive_(incomingFile);
  collapseAttachment_(payload, cells, headers, savedFile && savedFile.url ? {
    name: savedFile.name,
    url: savedFile.url,
    fileId: '',
    type: savedFile.type,
    size: savedFile.size,
    ts: new Date().toISOString()
  } : null);

  // Update columns (only if provided)
  cells[idx(headers, 'Submitted At')] = formatTs_(new Date());
  if (branch) cells[idx(headers, 'Branch')] = branch;
  if (executive) cells[idx(headers, 'Executive')] = executive;
  if (customerName) cells[idx(headers, 'Customer Name')] = customerName;
  if (mobileNumber) cells[idx(headers, 'Mobile Number')] = mobileNumber;

  if (company) cells[idx(headers, 'Company')] = company;
  if (model) cells[idx(headers, 'Model')] = model;
  if (variant) cells[idx(headers, 'Variant')] = variant;
  if (color) cells[idx(headers, 'Color')] = color;
  if (chassisNo) cells[idx(headers, 'Chassis Number')] = chassisNo;

  if (availability) cells[idx(headers, 'Chassis Availability')] = availability;
  if (availabilityBranch) cells[idx(headers, 'Availability Branch')] = availabilityBranch;

  if (purchaseMode) cells[idx(headers, 'Purchase Mode')] = purchaseMode;
  if (financier) cells[idx(headers, 'Financier')] = financier;
  if (rtoOffice) cells[idx(headers, 'RTO Office')] = rtoOffice;
  if (address) cells[idx(headers, 'Address')] = address;

  if (addressProofMode) cells[idx(headers, 'Address Proof Mode')] = addressProofMode;
  if (addressProofTypes) cells[idx(headers, 'Address Proof Types')] = addressProofTypes;
  if (bookingAmount) cells[idx(headers, 'Booking Amount')] = bookingAmount;

  // Actions (optional)
  if (data.status != null) cells[idx(headers, 'Status')] = String(data.status);
  if (data.notes != null) cells[idx(headers, 'Notes')] = String(data.notes);
  if (data.invoiceStatus != null) cells[idx(headers, 'Invoice Status')] = String(data.invoiceStatus);
  if (data.invoiceFileUrl != null) cells[idx(headers, 'Invoice File URL')] = String(data.invoiceFileUrl);
  if (data.insuranceStatus != null) cells[idx(headers, 'Insurance Status')] = String(data.insuranceStatus);
  if (data.insuranceFileUrl != null) cells[idx(headers, 'Insurance File URL')] = String(data.insuranceFileUrl);
  if (data.rtoStatus != null) cells[idx(headers, 'RTO Status')] = String(data.rtoStatus);
  const vehNo = data.vehicleNo || data.regNo;
  if (vehNo != null) cells[idx(headers, 'Vehicle No')] = String(vehNo);

  // Sanitize Raw Payload
  try {
    if (payload && payload.file && payload.file.base64) delete payload.file.base64;
    if (payload && typeof payload.rawPayload === 'string' && payload.rawPayload.length > 20000) {
      payload.rawPayload = payload.rawPayload.slice(0, 20000) + '‚Ä¶';
    }
  } catch (e) {}

  const rawStr = JSON.stringify(payload || {});
  cells[idx(headers, 'Raw Payload')] = rawStr.length > 45000
    ? JSON.stringify({ customerName, mobileNumber, vehicle: payload.vehicle || {}, payments: (payload.payments || []).slice(0, 5), note: 'payload truncated' })
    : rawStr;

  sh.getRange(existing.rowIndex, 1, 1, BOOKING_HEADERS.length).setValues([cells]);

  const id = String(cells[idx(headers, 'Booking ID')] || '');

  // Update DailyCollections with ONLY the additional amount added on edit
  // (First create is already handled in createNewBooking_)
  try {
    // Previous snapshot from existing row (before we overwrote it)
    var prevPayload = {};
    var rawIdx0 = headers.indexOf('Raw Payload');
    try { prevPayload = JSON.parse(String(rawIdx0 >= 0 ? (existing.rowData[rawIdx0] || '{}') : '{}')); } catch (_) { prevPayload = {}; }

    var toNum = function(x){ var n = Number(x || 0); return isNaN(n) ? 0 : n; };
    var prevBookIdx = headers.indexOf('Booking Amount');
    var prevSum = toNum(prevPayload && prevPayload.bookingAmount);
    if (!(prevSum > 0)) prevSum = toNum(prevBookIdx >= 0 ? existing.rowData[prevBookIdx] : 0);

    var prevPays = Array.isArray(prevPayload && prevPayload.payments) ? prevPayload.payments : [];
    var prevCash = prevPays.filter(function(p){ return String(p && p.mode || '').toLowerCase() === 'cash'; })
      .reduce(function(s,p){ return s + toNum(p && p.amount); }, 0);
    var prevOnline = prevPays.filter(function(p){ return String(p && p.mode || '').toLowerCase() === 'online'; })
      .reduce(function(s,p){ return s + toNum(p && p.amount); }, 0);

    var newSum = toNum(bookingAmount);
    var newCashTotal = toNum(data && data.cashCollected);
    var newOnlineTotal = toNum(data && data.onlineCollected);
    if (!(newCashTotal > 0) && !(newOnlineTotal > 0)) {
      newCashTotal = payments
        .filter(function(p){ return String(p && p.mode || '').toLowerCase() === 'cash'; })
        .reduce(function(s,p){ return s + toNum(p && p.amount); }, 0);
      newOnlineTotal = payments
        .filter(function(p){ return String(p && p.mode || '').toLowerCase() === 'online'; })
        .reduce(function(s,p){ return s + toNum(p && p.amount); }, 0);
    }

    var delta = newSum - prevSum;
    if (delta > 0) {
      var deltaCash = Math.max(0, newCashTotal - prevCash);
      var deltaOnline = Math.max(0, newOnlineTotal - prevOnline);
      if (!(deltaCash + deltaOnline > 0)) {
        if (newCashTotal > 0 && newOnlineTotal <= 0) deltaCash = delta;
        else if (newOnlineTotal > 0 && newCashTotal <= 0) deltaOnline = delta;
        else if (newCashTotal > 0 && newOnlineTotal > 0) {
          var tot = newCashTotal + newOnlineTotal;
          deltaCash = Math.round(delta * (newCashTotal / tot));
          deltaOnline = delta - deltaCash;
        } else {
          deltaCash = delta; // default fallback
        }
      }

      var bIdx = headers.indexOf('Branch');
      var eIdx = headers.indexOf('Executive');
      var branchUse = String(branch || (bIdx >= 0 ? cells[bIdx] : '') || '').trim();
      var execUse = String(executive || (eIdx >= 0 ? cells[eIdx] : '') || '').trim();
      if (branchUse && execUse) {
        var custIdx = headers.indexOf('Customer Name');
        var mobIdx = headers.indexOf('Mobile Number');
        var customerNameUse = String(customerName || (custIdx >= 0 ? cells[custIdx] : '') || payload.customerName || payload.name || '').trim();
        var customerMobileUse = String(mobileNumber || (mobIdx >= 0 ? cells[mobIdx] : '') || payload.mobileNumber || payload.mobile || '')
          .replace(/\D/g, '')
          .slice(-10);
        var paymentModeUse = String(data.paymentMode || data.purchaseMode || payload.paymentMode || '').toLowerCase();
        var ledgerCtx = {
          sourceType: 'booking',
          sourceId: id || '',
          bookingId: id || '',
          customerName: customerNameUse,
          customerMobile: customerMobileUse,
          paymentMode: paymentModeUse,
          payments: payments,
          deltaAmount: delta,
          deltaCash: deltaCash,
          deltaOnline: deltaOnline
        };
        updateDailyCollection_(branchUse, execUse, delta, 'booking', {
          cashCollected: deltaCash,
          onlineCollected: deltaOnline,
          staffLedgerContext: ledgerCtx,
        });
      }
    }
  } catch (_) { /* ignore DC errors on update */ }

  return { success: true, bookingId: id, action: 'updated' };
}

function createNewBooking_(data) {
  const v = data.vehicle || {};
  const company = data.company || v.company || '';
  const model = data.model || data.bikeModel || v.model || '';
  const variant = data.variant || v.variant || '';
  const color = data.color || v.color || '';
  const chassisNo = data.chassisNo || v.chassisNo || '';
  const availability = String(data.availability || v.availability || '');
  const availabilityBranch = (v && v.availabilityInfo && v.availabilityInfo.branch) ? v.availabilityInfo.branch : '';

  const branch = data.branch || '';
  const executive = data.executive || '';
  const customerName = data.customerName || data.name || '';
  const mobileNumber = data.mobileNumber || data.mobile || '';
  const rtoOffice = data.rtoOffice || '';
  const purchaseMode = data.purchaseMode || data.purchaseType || '';
  const financier = data.financier || data.nohpFinancier || '';
  const address = data.address || '';
  const addressProofMode = data.addressProofMode || data.addressProof || '';
  const addressProofTypes = Array.isArray(data.addressProofTypes) ? data.addressProofTypes.join(', ') : (data.addressProofTypes || '');
  let bookingAmount = data.bookingAmount || '';

  const payments = Array.isArray(data.payments) ? data.payments : [];
  if ((!bookingAmount || String(bookingAmount).trim() === '') && payments.length) {
    try {
      let sum = 0;
      for (let i = 0; i < payments.length; i++) {
        const a = Number(payments[i] && payments[i].amount ? payments[i].amount : 0) || 0;
        sum += a;
      }
      bookingAmount = String(sum);
    } catch (e) {}
  }
  const bookingAmountNum = Number(bookingAmount || 0) || 0;

  const incomingFile =
    data.file ||
    (Array.isArray(data.files) && data.files[0]) ||
    (Array.isArray(data.addressProofFiles) && data.addressProofFiles[0]) ||
    null;

  const savedFile = saveOneFileToDrive_(incomingFile);

  const bookingId = 'BK-' + new Date().getTime();
  const ts = formatTs_(new Date());

  const row = new Array(BOOKING_HEADERS.length).fill('');

  row[idx(BOOKING_HEADERS, 'Booking ID')] = bookingId;
  row[idx(BOOKING_HEADERS, 'Submitted At')] = ts;
  row[idx(BOOKING_HEADERS, 'Branch')] = branch;
  row[idx(BOOKING_HEADERS, 'Executive')] = executive;
  row[idx(BOOKING_HEADERS, 'Customer Name')] = customerName;
  row[idx(BOOKING_HEADERS, 'Mobile Number')] = mobileNumber;

  row[idx(BOOKING_HEADERS, 'Company')] = company;
  row[idx(BOOKING_HEADERS, 'Model')] = model;
  row[idx(BOOKING_HEADERS, 'Variant')] = variant;
  row[idx(BOOKING_HEADERS, 'Color')] = color;
  row[idx(BOOKING_HEADERS, 'Chassis Number')] = chassisNo;

  row[idx(BOOKING_HEADERS, 'Chassis Availability')] = availability;
  row[idx(BOOKING_HEADERS, 'Availability Branch')] = availabilityBranch;

  row[idx(BOOKING_HEADERS, 'Purchase Mode')] = purchaseMode;
  row[idx(BOOKING_HEADERS, 'Financier')] = financier;
  row[idx(BOOKING_HEADERS, 'RTO Office')] = rtoOffice;
  row[idx(BOOKING_HEADERS, 'Address')] = address;

  row[idx(BOOKING_HEADERS, 'Address Proof Mode')] = addressProofMode;
  row[idx(BOOKING_HEADERS, 'Address Proof Types')] = addressProofTypes;
  row[idx(BOOKING_HEADERS, 'Booking Amount')] = bookingAmount;

  row[idx(BOOKING_HEADERS, 'File Name')] = savedFile.name || '';
  row[idx(BOOKING_HEADERS, 'File URL')] = savedFile.url || '';
  row[idx(BOOKING_HEADERS, 'File Type')] = savedFile.type || '';
  row[idx(BOOKING_HEADERS, 'File Size')] = savedFile.size || '';

  row[idx(BOOKING_HEADERS, 'Status')] = 'pending';
  row[idx(BOOKING_HEADERS, 'Notes')] = '';

  const payload = JSON.parse(JSON.stringify(data || {}));
  try { if (payload && payload.file && payload.file.base64) delete payload.file.base64; } catch(e){}
  collapseAttachment_(payload, row, BOOKING_HEADERS, savedFile && savedFile.url ? {
    name: savedFile.name,
    url: savedFile.url,
    fileId: '',
    type: savedFile.type,
    size: savedFile.size,
    ts: new Date().toISOString()
  } : null);
  const rawStr = JSON.stringify(payload || {});
  row[idx(BOOKING_HEADERS, 'Raw Payload')] = rawStr.length > 45000
    ? JSON.stringify({ customerName, mobileNumber, vehicle: payload.vehicle || {}, note: 'payload truncated' })
    : rawStr;

  const sh = getSheet_();
  sh.appendRow(row);

  // üî¥ Log Booking Amount into master DailyCollections (with cash/online split)
  try {
    if (branch && executive && bookingAmountNum > 0) {
      let cashCollected = Number(data.cashCollected || 0) || 0;
      let onlineCollected = Number(data.onlineCollected || 0) || 0;

      const pays = Array.isArray(data.payments) ? data.payments : [];
      if (!(cashCollected > 0) && !(onlineCollected > 0) && pays.length) {
        cashCollected = pays
          .filter(p => String(p.mode||'').toLowerCase()==='cash')
          .reduce((s,p)=> s + (Number(p.amount)||0), 0);
        onlineCollected = pays
          .filter(p => String(p.mode||'').toLowerCase()==='online')
          .reduce((s,p)=> s + (Number(p.amount)||0), 0);
      }

      const ledgerCtx = {
        sourceType: 'booking',
        sourceId: bookingId,
        bookingId: bookingId,
        customerName,
        customerMobile: String(mobileNumber||'').replace(/\D/g,'').slice(-10),
        paymentMode: String(data.paymentMode || data.purchaseMode || '').toLowerCase(),
        payments: pays
      };
      updateDailyCollection_(branch, executive, bookingAmountNum, 'booking', {
        cashCollected,
        onlineCollected,
        staffLedgerContext: ledgerCtx
      });
    }
  } catch (e) {}

  return { success: true, bookingId, action: 'created' };
}

function checkDuplicate_(mobile, bookingId) {
  const existing = findExistingBooking_(mobile, bookingId);
  return {
    ok: true,
    duplicate: existing.found,
    existingRecord: existing.found ? {
      bookingId: existing.rowData[0] || '',
      customerName: existing.rowData[4] || '',
      mobile: existing.rowData[5] || '',
      timestamp: existing.rowData[1] || '',
      matchType: existing.matchType
    } : null
  };
}

// Patch-style small updates (status, invoice link, etc.)
function updateBooking_(bookingId, patch, mobileOpt) {
  const sh = getSheet_();
  const headers = sh.getRange(1, 1, 1, BOOKING_HEADERS.length).getValues()[0];
  const rowIndex = findRowIndexBy_(sh, headers, bookingId, mobileOpt);
  if (rowIndex < 2) return { success: false, error: 'not_found' };

  const cur = sh.getRange(rowIndex, 1, 1, BOOKING_HEADERS.length).getValues()[0];
  const cells = headers.map((_, i) => cur[i] || '');

  if (patch.status != null) cells[idx(headers, 'Status')] = String(patch.status);
  if (patch.notes != null) cells[idx(headers, 'Notes')] = String(patch.notes);

  if (patch.invoiceStatus != null) cells[idx(headers, 'Invoice Status')] = String(patch.invoiceStatus);
  if (patch.invoiceFileUrl != null) cells[idx(headers, 'Invoice File URL')] = String(patch.invoiceFileUrl);

  if (patch.insuranceStatus != null) cells[idx(headers, 'Insurance Status')] = String(patch.insuranceStatus);
  if (patch.insuranceFileUrl != null) cells[idx(headers, 'Insurance File URL')] = String(patch.insuranceFileUrl);

  if (patch.rtoStatus != null) cells[idx(headers, 'RTO Status')] = String(patch.rtoStatus);

  const chassis = (patch.chassis != null ? patch.chassis : patch.chassisNo);
  if (patch.chassis != null || patch.chassisNo != null) {
    cells[idx(headers, 'Chassis Number')] = String(chassis || '');
    const rawIdx = idx(headers, 'Raw Payload');
    var payload = {};
    try { payload = JSON.parse(String(cells[rawIdx] || '{}')); } catch (e) { payload = {}; }
    payload.vehicle = payload.vehicle || {};
    payload.vehicle.chassisNo = String(chassis || '');
    cells[rawIdx] = JSON.stringify(payload);
  }

  const vehNo = patch.vehicleNo || patch.regNo;
  if (vehNo != null) cells[idx(headers, 'Vehicle No')] = String(vehNo);

  cells[idx(headers, 'Submitted At')] = formatTs_(new Date());
  sh.getRange(rowIndex, 1, 1, BOOKING_HEADERS.length).setValues([cells]);

  return { success: true, updated: true, bookingId: String(cells[idx(headers, 'Booking ID')] || '') };
}

function findRowIndexBy_(sh, headers, bookingId, mobileOpt) {
  const last = sh.getLastRow();
  if (last < 2) return -1;

  const idCol = headers.indexOf('Booking ID') + 1;
  const mobileCol = headers.indexOf('Mobile Number') + 1;
  const range = sh.getRange(2, 1, last - 1, headers.length).getValues();

  if (bookingId && idCol > 0) {
    for (var i = 0; i < range.length; i++) {
      if (String(range[i][idCol - 1]) === String(bookingId)) return i + 2;
    }
  }

  const mob = String(mobileOpt || '').replace(/\D/g, '').slice(-10);
  if (mob && mobileCol > 0) {
    for (var j = range.length - 1; j >= 0; j--) {
      const cell = String(range[j][mobileCol - 1] || '').replace(/\D/g, '').slice(-10);
      if (cell && cell === mob) return j + 2;
    }
  }
  return -1;
}

// Attach document helper (append/replace + Raw Payload attachments[])
function attachDocument_(bookingId, mobileOpt, file, docType, append, tsIso) {
  const sh = getSheet_();
  const headers = sh.getRange(1, 1, 1, BOOKING_HEADERS.length).getValues()[0];
  const rowIndex = findRowIndexBy_(sh, headers, bookingId, mobileOpt);
  if (rowIndex < 2) return { success: false, error: 'not_found' };

  const range = sh.getRange(rowIndex, 1, 1, BOOKING_HEADERS.length);
  const cells = range.getValues()[0];

  const fileNameIdx = idx(headers, 'File Name');
  const fileUrlIdx = idx(headers, 'File URL');
  const rawIdx = idx(headers, 'Raw Payload');

  const curName = String(cells[fileNameIdx] || '').trim();
  const curUrl = String(cells[fileUrlIdx] || '').trim();

  const newName = file.name || 'Document.pdf';
  const newUrl = file.url || (file.fileId ? 'https://drive.google.com/file/d/' + file.fileId + '/view' : '');
  if (!newUrl) return { success: false, error: 'missing_url' };

  // Always replace with latest document (append flag intentionally ignored)
  const nowIso = tsIso || new Date().toISOString();
  var payload = {};
  try { payload = JSON.parse(String(cells[rawIdx] || '{}')); } catch (e) { payload = {}; }
  payload.attachments = [{
    type: docType || 'Other',
    name: newName,
    url: newUrl,
    fileId: file.fileId || '',
    ts: nowIso
  }];
  cells[fileNameIdx] = newName;
  cells[fileUrlIdx] = newUrl;
  cells[idx(headers, 'File Type')] = cells[idx(headers, 'File Type')] || '';
  cells[idx(headers, 'File Size')] = cells[idx(headers, 'File Size')] || '';
  cells[rawIdx] = JSON.stringify(payload);

  cells[idx(headers, 'Submitted At')] = formatTs_(new Date());
  range.setValues([cells]);

  const id = String(cells[idx(headers, 'Booking ID')] || '');
  return { success: true, bookingId: id, appended: false, replaced: true };
}

// ===================== LIST / SEARCH =====================

function listBookings_(p) {
  const page = Math.max(1, _toInt(p && p.page, 1));
  const pageSize = Math.min(100, Math.max(1, _toInt(p && p.pageSize, 10)));

  const q = _lc((p && p.q) || '');
  const branch = _lc((p && p.branch) || '');
  const status = _lc((p && p.status) || '');
  const start = p && p.start ? +p.start : null;
  const end = p && p.end ? +p.end : null;

  const sh = getSheet_();
  const values = sh.getDataRange().getValues();
  if (!values || values.length <= 1) return { ok: true, data: [], total: 0 };

  const headers = values[0];
  const idxMap = {
    bookingId: headers.indexOf('Booking ID'),
    submittedAt: headers.indexOf('Submitted At'),
    branch: headers.indexOf('Branch'),
    name: headers.indexOf('Customer Name'),
    mobile: headers.indexOf('Mobile Number'),
    company: headers.indexOf('Company'),
    model: headers.indexOf('Model'),
    variant: headers.indexOf('Variant'),
    chassis: headers.indexOf('Chassis Number'),
    status: headers.indexOf('Status'),
    remarkLevel: headers.indexOf('RemarkLevel'),
    remarkText: headers.indexOf('RemarkText'),
    raw: headers.indexOf('Raw Payload'),
  };

  const allRows = [];
  for (var i = 1; i < values.length; i++) {
    const rowObj = {};
    for (var j = 0; j < headers.length; j++) rowObj[headers[j]] = values[i][j];

    // Prefer dedicated remark columns; fall back to payload.remark
    var remarkLevelFromCol = idxMap.remarkLevel >= 0 ? String(values[i][idxMap.remarkLevel] || '') : '';
    var remarkTextFromCol = idxMap.remarkText >= 0 ? String(values[i][idxMap.remarkText] || '') : '';
    if (!remarkLevelFromCol && idxMap.raw >= 0) {
      var payload = {};
      try { payload = JSON.parse(String(values[i][idxMap.raw] || '{}')); } catch (e) { payload = {}; }
      var pr = payload && payload.remark ? payload.remark : null;
      remarkLevelFromCol = pr && pr.level ? String(pr.level).toUpperCase() : '';
      remarkTextFromCol = pr && pr.text ? String(pr.text) : '';
    }
    rowObj.RemarkLevel = remarkLevelFromCol;
    rowObj.RemarkText = remarkTextFromCol;

    var tsMs = 0;
    if (idxMap.submittedAt >= 0) {
      var v = values[i][idxMap.submittedAt];
      if (v instanceof Date) tsMs = v.getTime();
      else if (v) { var d = new Date(v); if (!isNaN(d.getTime())) tsMs = d.getTime(); }
    }
    rowObj.__tsMs = tsMs;

    allRows.push(rowObj);
  }

  let rows = allRows.filter(function (r) {
    if (branch && !_contains(r['Branch'], branch)) return false;
    if (status && _lc(r['Status']) !== status) return false;
    if (start && end) {
      var t = r.__tsMs || 0;
      if (!t || t < start || t > end) return false;
    }
    if (q) {
      var hay = [
        r['Booking ID'], r['Customer Name'], r['Mobile Number'], r['Company'],
        r['Model'], r['Variant'], r['Chassis Number'], r['Branch']
      ];
      var hit = false;
      for (var k = 0; k < hay.length; k++) { if (_contains(hay[k], q)) { hit = true; break; } }
      if (!hit) return false;
    }
    return true;
  });

  rows.sort(function (a, b) { return (b.__tsMs || 0) - (a.__tsMs || 0); });

  const total = rows.length;
  const startIdx = (page - 1) * pageSize;
  const data = rows.slice(startIdx, startIdx + pageSize);

  for (var r = 0; r < data.length; r++) { delete data[r].__tsMs; }

  return { ok: true, data: data, total: total };
}

function searchBookings_(mode, query) {
  if (!query) return { ok: true, rows: [] };
  const sh = getSheet_();
  const values = sh.getDataRange().getValues();
  const out = [];

  if (values && values.length > 1) {
    const headers = values[0];
    const idxMap = {
      bookingId: headers.indexOf('Booking ID'),
      mobile: headers.indexOf('Mobile Number'),
      vehicle: headers.indexOf('Vehicle No'),
      raw: headers.indexOf('Raw Payload'),
    };

    for (var i = 1; i < values.length; i++) {
      const id = idxMap.bookingId >= 0 ? String(values[i][idxMap.bookingId]) : '';
      const mobile = idxMap.mobile >= 0 ? String(values[i][idxMap.mobile]) : '';
      const vehicle = idxMap.vehicle >= 0 ? normReg_(values[i][idxMap.vehicle]) : '';
      const raw = idxMap.raw >= 0 ? String(values[i][idxMap.raw]) : '';

      const isBookingId = mode === 'booking';
      const isVehicle = mode === 'vehicle' || mode === 'reg';
      const qMobile = String(query).replace(/\D/g, '').slice(-10);
      const qReg = normReg_(query);

      let hit = false;
      if (isBookingId) {
        hit = id === query;
      } else if (isVehicle) {
        const regFromRaw = normReg_((function(){
          try {
            const pj = JSON.parse(raw || '{}');
            return pj && pj.vehicle && (pj.vehicle.regNo || pj.vehicle.registrationNumber || pj.vehicleNo || pj.regNo) || '';
          } catch (_) { return ''; }
        })());
        hit = qReg && (vehicle === qReg || regFromRaw === qReg);
      } else {
        hit = mobile.replace(/\D/g, '').slice(-10) === qMobile;
      }
      if (!hit) continue;

      var payload = {};
      try { payload = JSON.parse(raw || '{}'); } catch (e) { payload = {}; }

      if (!payload.branch) payload.branch = getCell_(headers, values[i], 'Branch');
      if (!payload.executive) payload.executive = getCell_(headers, values[i], 'Executive');
      if (!payload.customerName && !payload.name) payload.customerName = getCell_(headers, values[i], 'Customer Name');
      if (!payload.mobileNumber && !payload.mobile) payload.mobileNumber = getCell_(headers, values[i], 'Mobile Number');

      if (!payload.vehicle) payload.vehicle = {};
      payload.vehicle.company = payload.vehicle.company || getCell_(headers, values[i], 'Company');
      payload.vehicle.model = payload.vehicle.model || getCell_(headers, values[i], 'Model');
      payload.vehicle.variant = payload.vehicle.variant || getCell_(headers, values[i], 'Variant');
      payload.vehicle.color = payload.vehicle.color || getCell_(headers, values[i], 'Color');
      payload.vehicle.chassisNo = payload.vehicle.chassisNo || getCell_(headers, values[i], 'Chassis Number');

      payload.rtoOffice = payload.rtoOffice || getCell_(headers, values[i], 'RTO Office');
      payload.address = payload.address || getCell_(headers, values[i], 'Address');
      payload.purchaseMode = payload.purchaseMode || payload.purchaseType || getCell_(headers, values[i], 'Purchase Mode');
      payload.financier = payload.financier || getCell_(headers, values[i], 'Financier');
      // Surface invoice/insurance links from sheet for UI consumers
      const invoiceUrl = getCell_(headers, values[i], 'Invoice File URL') || '';
      const insuranceUrl = getCell_(headers, values[i], 'Insurance File URL') || '';
      if (invoiceUrl) payload.invoiceFileUrl = payload.invoiceFileUrl || invoiceUrl;
      if (insuranceUrl) payload.insuranceFileUrl = payload.insuranceFileUrl || insuranceUrl;

      var fileName = getCell_(headers, values[i], 'File Name') || '';
      var fileUrl = getCell_(headers, values[i], 'File URL') || '';
      collapseAttachment_(payload, values[i], headers, null);

      out.push({ payload });
    }
  }
  return { ok: true, rows: out };
}

// ===================== HELPERS =====================

function uploadFile_(e) {
  const folder = DriveApp.getFolderById(BOOKING_DRIVE_FOLDER_ID);
  const files = (e && e.files) || {};
  const keys = Object.keys(files);
  if (!keys.length) return { ok: false, error: 'no_file' };

  const key = keys[0];
  const blob = files[key];
  if (!blob) return { ok: false, error: 'bad_blob' };

  const mime = String(blob.getContentType() || '').toLowerCase();
  if (mime !== BOOKING_ALLOWED_MIME) return { ok: false, error: 'invalid_type_only_pdf_allowed' };

  var bytes = blob.getBytes();
  if (!bytes) return { ok: false, error: 'empty_file' };
  if (bytes.length > BOOKING_MAX_FILE_BYTES) return { ok: false, error: 'file_too_large_>5MB' };

  const file = folder.createFile(blob);
  try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (err) {}

  const id = file.getId();
  return {
    ok: true,
    fileId: id,
    url: 'https://drive.google.com/file/d/' + id + '/view',
    downloadUrl: 'https://drive.google.com/uc?export=download&id=' + id,
    name: file.getName(),
    mimeType: file.getMimeType(),
    size: file.getSize(),
  };
}

function uploadBase64_(body) {
  try {
    const name = String(body.name || 'document.pdf');
    const b64 = String(body.base64 || '');
    if (!b64) return { ok: false, success: false, error: 'missing_base64' };

    const bytes = Utilities.base64Decode(b64);
    if (!bytes || !bytes.length) return { ok: false, success: false, error: 'empty_file' };
    if (bytes.length > BOOKING_MAX_FILE_BYTES) return { ok: false, success: false, error: 'file_too_large_>5MB' };

    const folder = DriveApp.getFolderById(BOOKING_DRIVE_FOLDER_ID);
    const blob = Utilities.newBlob(bytes, BOOKING_ALLOWED_MIME, name);
    const file = folder.createFile(blob);
    try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (e) {}

    const id = file.getId();
    return {
      ok: true,
      success: true,
      fileId: id,
      url: 'https://drive.google.com/file/d/' + id + '/view',
      downloadUrl: 'https://drive.google.com/uc?export=download&id=' + id,
      name: file.getName(),
      mimeType: file.getMimeType(),
      size: file.getSize(),
    };
  } catch (err) {
    return { ok: false, success: false, error: String(err) };
  }
}

function getSpreadsheet_() {
  return BOOKING_SPREADSHEET_ID ? openSpreadsheet(BOOKING_SPREADSHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
}

function getSheet_() {
  const ss = getSpreadsheet_();
  let sh = ss.getSheetByName(BOOKING_SHEET_NAME);
  if (!sh) {
    sh = ss.insertSheet(BOOKING_SHEET_NAME);
    ensureHeaderRow_(sh);
  } else {
    const first = sh.getRange(1, 1, 1, BOOKING_HEADERS.length).getValues()[0];
    if (!first || first[0] !== BOOKING_HEADERS[0]) {
      sh.clear();
      ensureHeaderRow_(sh);
    }
  }
  return sh;
}

function ensureHeaderRow_(sh) {
  const need = BOOKING_HEADERS.length;
  const have = sh.getMaxColumns();
  if (have < need) sh.insertColumnsAfter(have, need - have);
  sh.getRange(1, 1, 1, BOOKING_HEADERS.length).setValues([BOOKING_HEADERS]);
  sh.setFrozenRows(1);
}

function saveOneFileToDrive_(f) {
  if (!f) return { name: '', url: '', type: '', size: '' };
  try {
    const name = f.name || '';
    const type = (f.mimeType || f.type || '').toLowerCase() || BOOKING_ALLOWED_MIME;
    const size = f.size || '';

    if (type !== BOOKING_ALLOWED_MIME) return { name: '', url: '', type: '', size: '', error: 'invalid_type_only_pdf_allowed' };

    if (f.fileId) {
      const file = DriveApp.getFileById(f.fileId);
      try { file.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (e) {}
      if (file.getSize() > BOOKING_MAX_FILE_BYTES) return { name: '', url: '', type: '', size: '', error: 'file_too_large_>5MB' };
      return {
        name: file.getName(),
        url: 'https://drive.google.com/file/d/' + f.fileId + '/view',
        type: file.getMimeType(),
        size: size || file.getSize()
      };
    }
    if (f.url || f.fileUrl) {
      const url = f.url || f.fileUrl;
      return { name: name, url: url, type: type, size: size };
    }

    if (f.base64) {
      const bytes = Utilities.base64Decode(f.base64);
      if (bytes.length > BOOKING_MAX_FILE_BYTES) return { name: '', url: '', type: '', size: '', error: 'file_too_large_>5MB' };
      const folder = DriveApp.getFolderById(BOOKING_DRIVE_FOLDER_ID);
      const blob = Utilities.newBlob(bytes, type, name || 'document.pdf');
      const newFile = folder.createFile(blob);
      try { newFile.setSharing(DriveApp.Access.ANYONE_WITH_LINK, DriveApp.Permission.VIEW); } catch (e) {}
      return {
        name: newFile.getName(),
        url: 'https://drive.google.com/file/d/' + newFile.getId() + '/view',
        type: type,
        size: size || bytes.length
      };
    }

    return { name: name, url: '', type: type, size: size };
  } catch (e) {
    return {
      name: (f && f.name) || '(error)',
      url: '',
      type: (f && (f.mimeType || f.type)) || '',
      size: (f && f.size) || ''
    };
  }
}

// Normalize attachments to a single latest entry and rewrite sheet/file columns
function collapseAttachment_(payload, cells, headers, overrideAtt) {
  var nameIdx = idx(headers, 'File Name');
  var urlIdx = idx(headers, 'File URL');
  var typeIdx = idx(headers, 'File Type');
  var sizeIdx = idx(headers, 'File Size');

  var nowIso = new Date().toISOString();
  var att = null;

  if (overrideAtt && overrideAtt.url) {
    att = {
      name: overrideAtt.name || 'Document',
      url: overrideAtt.url,
      fileId: overrideAtt.fileId || '',
      type: overrideAtt.type || '',
      size: overrideAtt.size || '',
      ts: overrideAtt.ts || nowIso
    };
  }

  if (!att && Array.isArray(payload && payload.attachments) && payload.attachments.length) {
    var last = payload.attachments[payload.attachments.length - 1] || {};
    var urlFromAtt = last.url || (last.fileId ? ('https://drive.google.com/file/d/' + last.fileId + '/view') : '');
    if (urlFromAtt) {
      att = {
        name: last.name || 'Document',
        url: urlFromAtt,
        fileId: last.fileId || '',
        type: last.type || '',
        size: last.size || '',
        ts: last.ts || nowIso
      };
    }
  }

  if (!att) {
    var curName = String(cells[nameIdx] || '');
    var curUrl = String(cells[urlIdx] || '');
    var urls = curUrl.split(',').map(function (s) { return s.trim(); }).filter(Boolean);
    var names = curName.split(',').map(function (s) { return s.trim(); }).filter(Boolean);
    if (urls.length) {
      var u = urls[urls.length - 1];
      var n = names.length ? names[Math.min(names.length - 1, urls.length - 1)] : '';
      att = {
        name: n || 'Document',
        url: u,
        fileId: '',
        type: String(cells[typeIdx] || ''),
        size: cells[sizeIdx] || '',
        ts: nowIso
      };
    }
  }

  if (!att || !att.url) {
    payload.attachments = Array.isArray(payload.attachments) ? payload.attachments.slice(-1) : [];
    return;
  }

  cells[nameIdx] = att.name || '';
  cells[urlIdx] = att.url;
  cells[typeIdx] = att.type || '';
  cells[sizeIdx] = att.size || '';
  payload.attachments = [{
    type: att.type || 'BookingDoc',
    name: att.name || 'Document',
    url: att.url,
    fileId: att.fileId || '',
    ts: att.ts || nowIso
  }];
}

function formatTs_(d) {
  return Utilities.formatDate(d, Session.getScriptTimeZone() || 'Asia/Kolkata', 'yyyy-MM-dd HH:mm:ss');
}

function json_(obj) {
  return ContentService
    .createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function getCell_(headers, row, key) {
  const i = headers.indexOf(key);
  return i >= 0 ? row[i] : '';
}

function parseJson_(raw, def) {
  try { return JSON.parse(raw || '{}'); } catch (e) { return def; }
}

function normReg_(s) {
  return String(s || '').toUpperCase().replace(/[^A-Z0-9]/g, '');
}

function idx(arr, key) {
  const i = arr.indexOf(key);
  if (i < 0) throw new Error('Missing header: ' + key);
  return i;
}

/* ========== Remarks (sheet-only) ========== */
function updateRemark_(bookingId, level, text, by) {
  if (!bookingId) return { success: false, error: 'bookingId required' };
  var lv = String(level || '').toLowerCase();
  if (!/(^ok$|^warning$|^alert$)/.test(lv)) return { success: false, error: 'level must be ok|warning|alert' };

  var sh = getSheet_();
  var headers = sh.getRange(1, 1, 1, sh.getLastColumn() || BOOKING_HEADERS.length).getValues()[0];
  // Ensure remark columns exist even on old sheets
  var remarkCols = ensureRemarkCols_(sh, headers);
  headers = remarkCols.headers;
  var idCol = remarkCols.idxBookingId + 1;
  var payloadCol = remarkCols.idxRaw + 1;
  var remarkLevelCol = remarkCols.idxRemarkLevel + 1;
  var remarkTextCol = remarkCols.idxRemarkText + 1;

  var last = sh.getLastRow();
  if (last < 2) return { success: false, error: 'empty_sheet' };

  var range = sh.getRange(2, 1, last - 1, headers.length).getValues();
  var targetRow = -1;
  for (var i = range.length - 1; i >= 0; i--) {
    var id = String(range[i][idCol - 1] || '').trim();
    if (id === bookingId) { targetRow = i + 2; break; }
  }
  if (targetRow < 0) return { success: false, error: 'not_found' };

  var raw = sh.getRange(targetRow, payloadCol).getValue();
  var payload = {};
  try { payload = JSON.parse(String(raw || '{}')); } catch (e) { payload = {}; }

  var nowIso = new Date().toISOString();
  payload.remark = {
    level: lv,
    text: String(text || '').slice(0, 240),
    by: String(by || '').slice(0, 120),
    at: nowIso
  };

  // Persist to dedicated columns for resilience (Jobcards parity)
  sh.getRange(targetRow, remarkLevelCol).setValue(String(lv).toUpperCase());
  sh.getRange(targetRow, remarkTextCol).setValue(String(text || '').slice(0, 240));
  // Mirror in payload for backward compatibility
  sh.getRange(targetRow, payloadCol).setValue(JSON.stringify(payload));
  return {
    success: true,
    updated: true,
    row: targetRow,
    bookingId: bookingId,
    level: lv,
    text: String(text || '')
  };
}

function _toInt(v, d) { var n = parseInt(v, 10); return isNaN(n) ? d : n; }
function _lc(s) { return String(s || '').toLowerCase(); }
function _contains(hay, needle) { return _lc(hay || '').indexOf(_lc(needle || '')) !== -1; }

// Guarantee remark columns exist and return indexes
function ensureRemarkCols_(sh, headersArr) {
  var headers = headersArr.slice();
  var idxBookingId = headers.indexOf('Booking ID');
  var idxRaw = headers.indexOf('Raw Payload');
  var idxRemarkLevel = headers.indexOf('RemarkLevel');
  var idxRemarkText = headers.indexOf('RemarkText');

  var appendCols = [];
  if (idxRemarkLevel < 0) { appendCols.push('RemarkLevel'); }
  if (idxRemarkText < 0) { appendCols.push('RemarkText'); }
  if (appendCols.length) {
    var start = headers.length + 1;
    sh.getRange(1, start, 1, appendCols.length).setValues([appendCols]);
    headers = headers.concat(appendCols);
    idxRemarkLevel = headers.indexOf('RemarkLevel');
    idxRemarkText = headers.indexOf('RemarkText');
  }
  return {
    headers: headers,
    idxBookingId: idxBookingId,
    idxRaw: idxRaw,
    idxRemarkLevel: idxRemarkLevel,
    idxRemarkText: idxRemarkText
  };
}

/* ============== DAILY COLLECTIONS (BOOKING AMOUNT) ============== */

const BOOKING_DC_SHEET = 'DailyCollections';
const BOOKING_DC_HEADERS = [
  'Date','Branch','Staff',
  'Booking Amount','JC Amount','Minor Sales Amount',
  'Total', // legacy total
  'Cash Amount','Online Amount','Total Collected',
  'Opening Balance','Due Today','Collected Today','Closing Balance',
  'Settlement Done','Settlement At','Updated At','Notes','Raw Payload'
];

function dcTodayStrIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');
}

function dcTsIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}

function dcToNum_(x) {
  const n = Number(x || 0);
  return isNaN(n) ? 0 : n;
}

// üî¥ use master spreadsheet, not local bookings file
function dcGetSheet_() {
  const masterId = typeof BOOKING_DC_MASTER_SPREADSHEET_ID === 'string'
    ? BOOKING_DC_MASTER_SPREADSHEET_ID
    : '';
  const ss = masterId
    ? openSpreadsheet(masterId)
    : getSpreadsheet_(); // fallback

  let sh = ss.getSheetByName(BOOKING_DC_SHEET);
  if (!sh) sh = ss.insertSheet(BOOKING_DC_SHEET);

  const w = Math.max(sh.getLastColumn(), BOOKING_DC_HEADERS.length);
  const first = sh.getRange(1,1,1,w).getValues()[0];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,BOOKING_DC_HEADERS.length).setValues([BOOKING_DC_HEADERS]);

  return sh;
}

// tolerant column finder
function dcFindCol_(headers, names) {
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  for (var i = 0; i < names.length; i++) {
    var j = H.indexOf(String(names[i]||'').trim().toLowerCase());
    if (j >= 0) return j;
  }
  return -1;
}

// tolerant index map (supports ‚ÄúMinor Sales Amt‚Äù too)
function dcIdx_(headers) {
  return {
    Date:    dcFindCol_(headers, ['Date']),
    Branch:  dcFindCol_(headers, ['Branch']),
    Staff:   dcFindCol_(headers, ['Staff']),
    Booking: dcFindCol_(headers, ['Booking Amount']),
    JC:      dcFindCol_(headers, ['JC Amount']),
    Minor:   dcFindCol_(headers, ['Minor Sales Amount', 'Minor Sales Amt']),
    Total:   dcFindCol_(headers, ['Total']),
    Cash:    dcFindCol_(headers, ['Cash Amount']),
    Online:  dcFindCol_(headers, ['Online Amount']),
    TotalCollected: dcFindCol_(headers, ['Total Collected']),
    Opening:  dcFindCol_(headers, ['Opening Balance']),
    Due:      dcFindCol_(headers, ['Due Today']),
    CollectedToday: dcFindCol_(headers, ['Collected Today']),
    Closing:  dcFindCol_(headers, ['Closing Balance']),
    Done:    dcFindCol_(headers, ['Settlement Done']),
    At:      dcFindCol_(headers, ['Settlement At']),
    UpdatedAt: dcFindCol_(headers, ['Updated At']),
    Raw:     dcFindCol_(headers, ['Raw Payload']),
    width: headers.length
  };
}

// Normalize any date cell to yyyy-MM-dd
function dcNormDate_(val) {
  var tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  if (val instanceof Date) return Utilities.formatDate(val, tz, 'yyyy-MM-dd');
  var s = String(val || '');
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  var d = new Date(s);
  if (!isNaN(d.getTime())) return Utilities.formatDate(d, tz, 'yyyy-MM-dd');
  return s;
}

/**
 * updateDailyCollection_(branch, staff, amount, type, opt?)
 * type = 'booking' | 'jc' | 'minorsales'
 * opt  = { cashCollected?: number, onlineCollected?: number }
 */
function updateDailyCollection_(branch, staff, amount, type, opt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const amt = dcToNum_(amount);
  const cashInc = dcToNum_(opt && opt.cashCollected);
  const onlineInc = dcToNum_(opt && opt.onlineCollected);

  if (!b || !s || !(amt > 0)) {
    return { success:false, message:'missing branch/staff or amount<=0' };
  }

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const dateStr = dcTodayStrIndia_();

  const last = sh.getLastRow();
  let hit = -1;

  // Find existing unsettled row
  if (last > 1) {
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      const sameDate   = dcNormDate_(r[I.Date]) === dateStr;
      const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
      const sameStaff  = String(r[I.Staff]  || '').trim().toLowerCase() === s.toLowerCase();
      const notDone    = String(r[I.Done]   || '').toLowerCase() !== 'true';
      if (sameDate && sameBranch && sameStaff && notDone) {
        hit = i + 2;
        break;
      }
    }
  }

  if (hit < 0) {
    // Create new row
    const row = new Array(I.width).fill('');
    row[I.Date]   = dateStr;
    row[I.Branch] = b;
    row[I.Staff]  = s;

    row[I.Booking] = 0;
    row[I.JC]      = 0;
    row[I.Minor]   = 0;

    if (type === 'booking')         row[I.Booking] = amt;
    else if (type === 'jc')         row[I.JC]      = amt;
    else if (type === 'minorsales') row[I.Minor]   = amt;

    row[I.Total] = dcToNum_(row[I.Booking]) + dcToNum_(row[I.JC]) + dcToNum_(row[I.Minor]);
    if (I.TotalCollected >= 0) row[I.TotalCollected] = dcToNum_(row[I.Cash]) + dcToNum_(row[I.Online]);

    if (I.Cash >= 0)   row[I.Cash]   = cashInc;
    if (I.Online >= 0) row[I.Online] = onlineInc;

    row[I.Done]  = false;
    row[I.At]    = '';
    row[I.Raw]   = JSON.stringify({ createdAt: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });

    sh.appendRow(row);
    hit = sh.getLastRow();
  } else {
    // Update existing row
    const cur = sh.getRange(hit,1,1,I.width).getValues()[0];

    if (type === 'booking')         cur[I.Booking] = dcToNum_(cur[I.Booking]) + amt;
    else if (type === 'jc')         cur[I.JC]      = dcToNum_(cur[I.JC]) + amt;
    else if (type === 'minorsales') cur[I.Minor]   = dcToNum_(cur[I.Minor]) + amt;

    cur[I.Total] = dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]);
    if (I.TotalCollected >= 0) cur[I.TotalCollected] = dcToNum_(cur[I.Cash]) + dcToNum_(cur[I.Online]);

    if (I.Cash >= 0)   cur[I.Cash]   = dcToNum_(cur[I.Cash])   + cashInc;
    if (I.Online >= 0) cur[I.Online] = dcToNum_(cur[I.Online]) + onlineInc;

    if (I.Raw >= 0) {
      let raw = {};
      try { raw = JSON.parse(String(cur[I.Raw] || '{}')); } catch (_) { raw = {}; }
      if (!Array.isArray(raw.logs)) raw.logs = [];
      raw.logs.push({ at: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });
      try { cur[I.Raw] = JSON.stringify(raw); } catch (_) { /* ignore */ }
    }

    // Write only the columns that actually exist to avoid shape issues
    try { if (I.Booking >= 0) sh.getRange(hit, I.Booking + 1).setValue(cur[I.Booking]); } catch(_) {}
    try { if (I.JC      >= 0) sh.getRange(hit, I.JC      + 1).setValue(cur[I.JC]); } catch(_) {}
    try { if (I.Minor   >= 0) sh.getRange(hit, I.Minor   + 1).setValue(cur[I.Minor]); } catch(_) {}
    try { if (I.Cash    >= 0) sh.getRange(hit, I.Cash    + 1).setValue(cur[I.Cash]); } catch(_) {}
    try { if (I.Online  >= 0) sh.getRange(hit, I.Online  + 1).setValue(cur[I.Online]); } catch(_) {}
    try { if (I.Total   >= 0) sh.getRange(hit, I.Total   + 1).setValue(cur[I.Total]); } catch(_) {}
  }

  // NEW: Append to StaffLedger (non-breaking)
  try {
    staffLedgerAppendFromDailyUpdate_(b, s, amt, type, opt);
  } catch (_){ /* ignore ledger errors to preserve current flow */ }

  const out = sh.getRange(hit,1,1,I.width).getValues()[0];

  return {
    success:true,
    updatedRow: {
      date:   out[I.Date],
      branch: out[I.Branch],
      staff:  out[I.Staff],
      booking: dcToNum_(out[I.Booking]),
      jc:      dcToNum_(out[I.JC]),
      minor:   dcToNum_(out[I.Minor]),
      cashAmount: (I.Cash>=0 ? dcToNum_(out[I.Cash]) : 0),
      onlineAmount: (I.Online>=0 ? dcToNum_(out[I.Online]) : 0),
      total:   dcToNum_(out[I.Total]),
      settled: String(out[I.Done]).toLowerCase() === 'true',
      settledAt: out[I.At] || ''
    }
  };
}

/* ============================
   StaffLedger (NEW HELPERS)
============================ */
const STAFF_LEDGER_SHEET = 'StaffLedger';
const STAFF_LEDGER_HEADERS = [
  'DateTime ISO','Date','Branch','Staff',
  'Source Type','Source ID',
  'Customer Name','Customer Mobile',
  'Payment Mode','Cash Amount','Online Amount','UTR / Ref No',
  'Collected Total','Settled Cash','Settled Online','Settled Total',
  'Settled Flag','Settled At','Settled By','Raw Payload'
];

function slNowIsoIndia_(){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function slDateIndia_(d){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(d || new Date(), tz, 'yyyy-MM-dd');
}

function staffLedgerGetSheet_(){
  const masterId = typeof BOOKING_DC_MASTER_SPREADSHEET_ID === 'string' ? BOOKING_DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? openSpreadsheet(masterId) : getSpreadsheet_();
  let sh = ss.getSheetByName(STAFF_LEDGER_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_LEDGER_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_LEDGER_HEADERS.length).setValues([STAFF_LEDGER_HEADERS]);
  return sh;
}

function staffLedgerIdx_(headers){
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  const find = (name) => H.indexOf(String(name||'').trim().toLowerCase());
  return {
    DateTimeISO: find('datetime iso'),
    Date: find('date'),
    Branch: find('branch'),
    Staff: find('staff'),
    SrcType: find('source type'),
    SrcId: find('source id'),
    CustName: find('customer name'),
    CustMobile: find('customer mobile'),
    PayMode: find('payment mode'),
    Cash: find('cash amount'),
    Online: find('online amount'),
    UTR: find('utr / ref no'),
    Total: find('collected total'),
    SCash: find('settled cash'),
    SOnline: find('settled online'),
    STotal: find('settled total'),
    SFlag: find('settled flag'),
    SAt: find('settled at'),
    SBy: find('settled by'),
    Raw: find('raw payload'),
    width: headers.length
  };
}

function appendStaffLedgerTransaction_(rowObj){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const row = new Array(I.width).fill('');
  const put = (i,v)=>{ if (i>=0) row[i] = (v==null?'':v); };
  put(I.DateTimeISO, rowObj.dateTimeIso || slNowIsoIndia_());
  put(I.Date, rowObj.date || slDateIndia_(new Date()));
  put(I.Branch, rowObj.branch || '');
  put(I.Staff, rowObj.staff || '');
  put(I.SrcType, rowObj.sourceType || '');
  put(I.SrcId, rowObj.sourceId || '');
  put(I.CustName, rowObj.customerName || '');
  put(I.CustMobile, rowObj.customerMobile || '');
  put(I.PayMode, rowObj.paymentMode || '');
  put(I.Cash, Number(rowObj.cashAmount||0)||0);
  put(I.Online, Number(rowObj.onlineAmount||0)||0);
  put(I.UTR, rowObj.utr || '');
  const cash = Number(rowObj.cashAmount||0)||0;
  const online = Number(rowObj.onlineAmount||0)||0;
  put(I.Total, cash + online);
  put(I.SCash, 0);
  put(I.SOnline, 0);
  put(I.STotal, 0);
  put(I.SFlag, false);
  put(I.SAt, '');
  put(I.SBy, '');
  try { put(I.Raw, JSON.stringify(rowObj.rawPayload || {})); } catch(_){ put(I.Raw, ''); }
  sh.appendRow(row);
  return { row: sh.getLastRow() };
}

function staffLedgerAppendFromDailyUpdate_(branch, staff, amount, type, opt){
  try{
    const b = String(branch||'').trim();
    const s = String(staff||'').trim();
    const amt = dcToNum_(amount);
    if (!b || !s || !(amt>0)) return { skipped:true };
    const ctx = (opt && opt.staffLedgerContext) || {};
    let cash = dcToNum_(opt && opt.cashCollected);
    let online = dcToNum_(opt && opt.onlineCollected);
    if (!(cash>0) && !(online>0) && Array.isArray(ctx.payments)){
      try {
        cash = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='cash').reduce((a,p)=>a+(Number(p.amount)||0),0);
        online = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='online').reduce((a,p)=>a+(Number(p.amount)||0),0);
      } catch(_) {}
    }
    if (!(cash>0) && !(online>0)){
      const pm = String(ctx.paymentMode || '').toLowerCase();
      if (pm === 'cash') cash = amt; else if (pm) online = amt; else cash = amt;
    }
    const pmode = (cash>0 && online>0) ? 'mixed' : (cash>0 ? 'cash' : (online>0 ? 'online' : ''));
    let utr = String(ctx.utr||'').trim();
    if (!utr && Array.isArray(ctx.payments)){
      try {
        const p = ctx.payments.find(p=>String(p.mode||'').toLowerCase()==='online');
        utr = String(p && (p.utr || p.ref || p.reference || p.txnId || p.txn || p.upiRef || '')).trim();
      } catch(_) {}
    }
    const obj = {
      branch: b,
      staff: s,
      sourceType: String(type||'').toLowerCase(),
      sourceId: String(ctx.sourceId||ctx.bookingId||'').trim(),
      customerName: ctx.customerName || '',
      customerMobile: String(ctx.customerMobile || '').replace(/\D/g,'').slice(-10),
      paymentMode: pmode,
      cashAmount: cash,
      onlineAmount: online,
      utr: utr,
      rawPayload: { from: 'updateDailyCollection_', ctx }
    };
    return appendStaffLedgerTransaction_(obj);
  }catch(err){ return { error: String(err) }; }
}
__MODULES__.booking = { doGet, doPost };
})();

(() => {
// ====== BRANCHES =====
// Google Apps Script web app for Branch CRUD on Google Sheets
// - Deploy as a web app with "Anyone with the link" access
// - Configure BRANCHES_SHEET_ID + optional BRANCHES_API_KEY for auth

const BRANCHES_SHEET_ID = 'PUT_SPREADSHEET_ID_HERE'
const BRANCHES_SHEET_NAME = 'branches'
const BRANCHES_API_KEY = 'OPTIONAL_SECRET_KEY'

const TYPE_OPTIONS = ['sales', 'service', 'sales & services']
const STATUS_OPTIONS = ['active', 'inactive', 'under_maintenance']
const BRANCHES_HEADERS = [
  'id',
  'code',
  'name',
  'type',
  'phone',
  'email',
  'address_line1',
  'address_line2',
  'area',
  'city',
  'state',
  'pincode',
  'location_lng',
  'location_lat',
  'manager',
  'staff',
  'boys',
  'mechanics',
  'status',
  'openingHours',
  'metadata',
  'createdAt',
  'updatedAt',
]

function doGet(e) {
  return handleRequest('GET', e)
}

function doPost(e) {
  return handleRequest('POST', e)
}

function doOptions() {
  return respond({ success: true }, 204)
}

function handleRequest(method, e) {
  try {
    const body = parseBody(e)
    if (!isAuthorized(e, body)) return respond({ success: false, message: 'Unauthorized' }, 401)
    const action = (method === 'GET' ? e?.parameter?.action : body.action || e?.parameter?.action) || 'list'
    switch (action) {
      case 'get':
        return handleGet(e?.parameter)
      case 'bulkGet':
        return handleBulkGet(e?.parameter)
      case 'create':
        return handleCreate(body.payload || body)
      case 'update':
        return handleUpdate(body.id || body.payload?.id, body.payload || body)
      case 'delete':
        return handleDelete(body.id || e?.parameter?.id)
      case 'upsert':
        return handleUpsert(body.payload || body)
      case 'list':
      default:
        return handleList(e?.parameter)
    }
  } catch (err) {
    return respond({ success: false, message: err && err.message ? err.message : 'Internal error' }, 500)
  }
}

function isAuthorized(e, body) {
  if (!BRANCHES_API_KEY) return true
  const headerKey = (e?.headers && (e.headers['x-api-key'] || e.headers['X-Api-Key'])) || ''
  const paramKey = e?.parameter?.apiKey || e?.parameter?.key || ''
  const bodyKey = body?.apiKey || ''
  return BRANCHES_API_KEY && (BRANCHES_API_KEY === headerKey || BRANCHES_API_KEY === paramKey || BRANCHES_API_KEY === bodyKey)
}

function respond(payload, status) {
  var out = ContentService.createTextOutput(JSON.stringify(payload || {}))
  out.setMimeType(ContentService.MimeType.JSON)
  // Apps Script's TextOutput does not support setHeader; web app CORS is managed by Apps Script.
  // If you need strict CORS headers, wrap this in an HTML output with meta refresh or handle in client.
  if (typeof out.setResponseCode === 'function') {
    out.setResponseCode(status || 200)
  }
  return out
}

function parseBody(e) {
  if (!e || !e.postData || !e.postData.contents) return {}
  try {
    return JSON.parse(e.postData.contents)
  } catch (err) {
    return {}
  }
}

function sheet() {
  const ss = openSpreadsheet(BRANCHES_SHEET_ID)
  const sh = ss.getSheetByName(BRANCHES_SHEET_NAME) || ss.insertSheet(BRANCHES_SHEET_NAME)
  const headerRow = sh.getRange(1, 1, 1, BRANCHES_HEADERS.length).getValues()[0]
  if (headerRow.join('') !== BRANCHES_HEADERS.join('')) {
    sh.getRange(1, 1, 1, BRANCHES_HEADERS.length).setValues([BRANCHES_HEADERS])
  }
  return sh
}

function normalizeType(type) {
  const norm = String(type || '').trim().toLowerCase()
  const direct = TYPE_OPTIONS.find((t) => t.toLowerCase() === norm)
  if (direct) return direct
  const relaxed = TYPE_OPTIONS.find((t) => t.replace(/[^a-z]/g, '') === norm.replace(/[^a-z]/g, ''))
  return relaxed || 'sales & services'
}

function normalizeStatus(status) {
  const norm = String(status || '').trim().toLowerCase()
  const direct = STATUS_OPTIONS.find((t) => t.toLowerCase() === norm)
  return direct || 'active'
}

function parseArray(value) {
  if (!value) return []
  if (Array.isArray(value)) return value
  if (typeof value === 'string') {
    try {
      const parsed = JSON.parse(value)
      if (Array.isArray(parsed)) return parsed
    } catch (err) {
      // fall back to comma split
    }
    return value
      .split(',')
      .map(function (v) { return v.trim() })
      .filter(function (v) { return v })
  }
  return []
}

function parseJson(value, fallback) {
  if (value === undefined || value === null || value === '') return fallback
  if (typeof value === 'object') return value
  try {
    return JSON.parse(value)
  } catch (err) {
    return fallback
  }
}

function generateObjectId() {
  return Utilities.getUuid().replace(/-/g, '').slice(0, 24)
}

function rowToBranch(row) {
  var obj = {}
  BRANCHES_HEADERS.forEach(function (key, idx) {
    obj[key] = row[idx]
  })
  var branch = {
    id: String(obj.id || generateObjectId()),
    code: String(obj.code || '').trim().toUpperCase(),
    name: obj.name || '',
    type: normalizeType(obj.type),
    phone: obj.phone || '',
    email: (obj.email || '').toLowerCase(),
    address: {
      line1: obj.address_line1 || '',
      line2: obj.address_line2 || '',
      area: obj.area || '',
      city: obj.city || '',
      state: obj.state || '',
      pincode: obj.pincode || '',
    },
    location: (obj.location_lng || obj.location_lat)
      ? { type: 'Point', coordinates: [Number(obj.location_lng) || 0, Number(obj.location_lat) || 0] }
      : null,
    manager: obj.manager || null,
    staff: parseArray(obj.staff),
    boys: parseArray(obj.boys),
    mechanics: parseArray(obj.mechanics),
    status: normalizeStatus(obj.status),
    openingHours: parseJson(obj.openingHours, null),
    metadata: parseJson(obj.metadata, null),
    createdAt: obj.createdAt || new Date().toISOString(),
    updatedAt: obj.updatedAt || obj.createdAt || new Date().toISOString(),
  }
  branch.activeStaffCount = branch.staff.length
  branch.activeBoysCount = branch.boys.length
  branch.activeMechanicsCount = branch.mechanics.length
  branch.isSales = branch.type === 'sales' || branch.type === 'sales & services'
  branch.isService = branch.type === 'service' || branch.type === 'sales & services'
  return branch
}

function branchToRow(branch) {
  return [
    branch.id,
    branch.code,
    branch.name,
    normalizeType(branch.type),
    branch.phone || '',
    branch.email || '',
    branch.address && branch.address.line1 ? branch.address.line1 : '',
    branch.address && branch.address.line2 ? branch.address.line2 : '',
    branch.address && branch.address.area ? branch.address.area : '',
    branch.address && branch.address.city ? branch.address.city : '',
    branch.address && branch.address.state ? branch.address.state : '',
    branch.address && branch.address.pincode ? branch.address.pincode : '',
    branch.location && branch.location.coordinates ? branch.location.coordinates[0] : '',
    branch.location && branch.location.coordinates ? branch.location.coordinates[1] : '',
    branch.manager || '',
    JSON.stringify(branch.staff || []),
    JSON.stringify(branch.boys || []),
    JSON.stringify(branch.mechanics || []),
    normalizeStatus(branch.status),
    branch.openingHours ? JSON.stringify(branch.openingHours) : '',
    branch.metadata ? JSON.stringify(branch.metadata) : '',
    branch.createdAt || new Date().toISOString(),
    branch.updatedAt || new Date().toISOString(),
  ]
}

function readAllBranches() {
  var values = sheet().getDataRange().getValues()
  var rows = values.slice(1) // drop header
  return rows.map(rowToBranch)
}

function validateBranchPayload(payload, opts) {
  var options = opts || {}
  var existing = options.existing || {}
  var address = payload.address || {}
  var branch = {
    id: String(payload.id || payload._id || existing.id || generateObjectId()),
    code: String(payload.code || existing.code || '').trim().toUpperCase(),
    name: String(payload.name || existing.name || '').trim(),
    type: normalizeType(payload.type || existing.type),
    phone: payload.phone || existing.phone || '',
    email: (payload.email || existing.email || '').toLowerCase(),
    address: {
      line1: address.line1 || existing.address?.line1 || '',
      line2: address.line2 || existing.address?.line2 || '',
      area: address.area || existing.address?.area || '',
      city: address.city || existing.address?.city || '',
      state: address.state || existing.address?.state || '',
      pincode: address.pincode || existing.address?.pincode || '',
    },
    location: payload.location
      ? payload.location
      : payload.lat != null && payload.lng != null
        ? { type: 'Point', coordinates: [Number(payload.lng), Number(payload.lat)] }
        : existing.location || null,
    manager: payload.manager || payload.manager === null ? payload.manager : (existing.manager || null),
    staff: payload.staff != null ? parseArray(payload.staff) : (existing.staff || []),
    boys: payload.boys != null ? parseArray(payload.boys) : (existing.boys || []),
    mechanics: payload.mechanics != null ? parseArray(payload.mechanics) : (existing.mechanics || []),
    status: normalizeStatus(payload.status || existing.status),
    openingHours: payload.hasOwnProperty('openingHours') ? parseJson(payload.openingHours, null) : (existing.openingHours || null),
    metadata: payload.hasOwnProperty('metadata') ? parseJson(payload.metadata, null) : (existing.metadata || null),
    createdAt: payload.createdAt || existing.createdAt || new Date().toISOString(),
    updatedAt: payload.updatedAt || new Date().toISOString(),
  }

  if (!branch.code) throw new Error('code is required')
  if (!branch.name) throw new Error('name is required')
  if (!branch.address.city) throw new Error('address.city is required')

  return branch
}

function handleList(params) {
  var q = params && params.q ? String(params.q).toLowerCase() : ''
  var city = params && params.city ? String(params.city).toLowerCase() : ''
  var status = params && params.status ? String(params.status).toLowerCase() : ''
  var type = params && params.type ? String(params.type).toLowerCase() : ''
  var limit = params && params.limit ? parseInt(params.limit, 10) : 100
  var page = params && params.page ? parseInt(params.page, 10) : 1
  limit = isNaN(limit) ? 100 : limit
  page = isNaN(page) ? 1 : page

  var branches = readAllBranches()
  var filtered = branches.filter(function (b) {
    var matchesQ = true
    if (q) {
      var qrx = q
      matchesQ =
        (b.code && b.code.toLowerCase().indexOf(qrx) >= 0) ||
        (b.name && b.name.toLowerCase().indexOf(qrx) >= 0) ||
        (b.phone && String(b.phone).toLowerCase().indexOf(qrx) >= 0) ||
        (b.email && b.email.toLowerCase().indexOf(qrx) >= 0) ||
        (b.address.city && b.address.city.toLowerCase().indexOf(qrx) >= 0) ||
        (b.address.area && b.address.area.toLowerCase().indexOf(qrx) >= 0)
    }
    var matchesCity = !city || (b.address.city && b.address.city.toLowerCase() === city)
    var matchesStatus = !status || (b.status && b.status.toLowerCase() === status)
    var matchesType = !type || (b.type && b.type.toLowerCase() === type)
    return matchesQ && matchesCity && matchesStatus && matchesType
  })

  filtered.sort(function (a, b) {
    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
  })

  var total = filtered.length
  var start = Math.max((page - 1) * limit, 0)
  var items = filtered.slice(start, start + limit)

  return respond({ success: true, data: { items: items, total: total } })
}

function handleGet(params) {
  var id = params && params.id ? String(params.id) : ''
  var code = params && params.code ? String(params.code).toUpperCase() : ''
  if (!id && !code) return respond({ success: false, message: 'id or code is required' }, 400)
  var branches = readAllBranches()
  var item = branches.find(function (b) { return (id && b.id === id) || (code && b.code === code) })
  if (!item) return respond({ success: false, message: 'Branch not found' }, 404)
  return respond({ success: true, data: item })
}

function handleBulkGet(params) {
  var idsParam = params && params.ids ? params.ids : ''
  if (!idsParam) return respond({ success: true, data: { items: [], total: 0 } })
  var ids = idsParam.split(',').map(function (v) { return v.trim() }).filter(function (v) { return v })
  var branches = readAllBranches()
  var items = branches.filter(function (b) { return ids.indexOf(b.id) >= 0 })
  return respond({ success: true, data: { items: items, total: items.length } })
}

function handleCreate(payload) {
  var branch = validateBranchPayload(payload, {})
  var branches = readAllBranches()
  var duplicate = branches.find(function (b) { return b.code === branch.code || b.id === branch.id })
  if (duplicate) return respond({ success: false, message: 'Branch already exists' }, 409)
  sheet().appendRow(branchToRow(branch))
  return respond({ success: true, data: branch })
}

function handleUpdate(id, payload) {
  if (!id) return respond({ success: false, message: 'id is required' }, 400)
  var sh = sheet()
  var values = sh.getDataRange().getValues()
  var idx = values.findIndex(function (row, i) { return i > 0 && String(row[0]) === String(id) })
  if (idx < 0) return respond({ success: false, message: 'Branch not found' }, 404)
  var existing = rowToBranch(values[idx])
  var branch = validateBranchPayload(Object.assign({}, existing, payload, { id: id }), { existing: existing })
  sh.getRange(idx + 1, 1, 1, BRANCHES_HEADERS.length).setValues([branchToRow(branch)])
  return respond({ success: true, data: branch })
}

function handleUpsert(payload) {
  var sh = sheet()
  var values = sh.getDataRange().getValues()
  var targetId = String(payload.id || payload._id || '')
  var targetCode = String(payload.code || '').trim().toUpperCase()
  var matchIdx = values.findIndex(function (row, i) {
    if (i === 0) return false
    var rowId = String(row[0])
    var rowCode = String(row[1]).toUpperCase()
    return (targetId && rowId === targetId) || (targetCode && rowCode === targetCode)
  })
  if (matchIdx > 0) {
    var existing = rowToBranch(values[matchIdx])
    var merged = validateBranchPayload(Object.assign({}, existing, payload), { existing: existing })
    sh.getRange(matchIdx + 1, 1, 1, BRANCHES_HEADERS.length).setValues([branchToRow(merged)])
    return respond({ success: true, data: merged })
  }
  var branch = validateBranchPayload(payload, {})
  sh.appendRow(branchToRow(branch))
  return respond({ success: true, data: branch })
}

function handleDelete(id) {
  if (!id) return respond({ success: false, message: 'id is required' }, 400)
  var sh = sheet()
  var values = sh.getDataRange().getValues()
  var idx = values.findIndex(function (row, i) { return i > 0 && String(row[0]) === String(id) })
  if (idx < 0) return respond({ success: false, message: 'Branch not found' }, 404)
  sh.deleteRow(idx + 1)
  return respond({ success: true, message: 'Deleted' })
}
__MODULES__.branches = { doGet, doPost, doOptions };
})();

(() => {
// ====== JOBCARD =====
function doGet(e){ return handle_(e) }
function doPost(e){ return handle_(e) }

// If bound to the sheet, keep blank. Otherwise set your spreadsheet ID.
const JOBCARD_SHEET_ID = '';
const JOBCARD_SHEET_NAME = 'Job Quotes';

// Default headers (used only when the sheet is empty).
// Existing sheets are read dynamically and not overwritten.
const DEFAULT_HEADERS = [
  'Timestamp',
  'Customer_Name',
  'Mobile',
  'Collected_Amount',
  'Vehicle_No',
  'Service_Type',
  'Branch',
  'Customer_Observation',
  'Expected_Delivery_Date',
  'Payload',
  'Payment_Mode',
  'JC No.',
  'RemarkLevel',
  'RemarkText'
];

// Append-only service history (separate sheet; jcNo is idempotency key)
const SERVICE_HISTORY_SHEET = 'ServiceHistory';
const SERVICE_HISTORY_HEADERS = [
  'Created At',
  'Post Service At',
  'JC No',
  'Reg No',
  'Mobile',
  'Customer Name',
  'Branch',
  'Service Type',
  'Vehicle Type',
  'Model',
  'Colour',
  'Mechanic',
  'Executive',
  'Service No',
  'KM',
  'Fuel Level',
  'Payment Mode',
  'Collected Amount',
  'Totals Grand',
  'Work Done',
  'Remarks',
  'Payments JSON',
  'Payload JSON'
];

/* ============== DAILY COLLECTIONS (MASTER) CONFIG ============== */
const JOBCARD_DC_MASTER_SPREADSHEET_ID = MASTER_SPREADSHEET_ID;
const JOBCARD_DC_SHEET = 'DailyCollections';

const JOBCARD_DC_HEADERS = [
  'Date','Branch','Staff',
  'Booking Amount','JC Amount','Minor Sales Amount',
  'Total', // legacy total field (keep for compatibility)
  'Cash Amount','Online Amount','Total Collected', // total collected = cash + online
  'Opening Balance','Due Today','Collected Today','Closing Balance',
  'Settlement Done','Settlement At','Updated At','Notes','Raw Payload'
];

function handle_(e){
  try{
    const body = (e && e.postData && e.postData.contents) ? JSON.parse(e.postData.contents) : {};
    const action = String(
      (e && e.parameter && e.parameter.action) ||
      body.action ||
      (body.data && body.data.action) ||
      ''
    ).toLowerCase();

    if (action === 'nextserial') return json_({ success:true, nextSerial: nextSerial_() });

    if (action === 'list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = String((p.branch != null ? p.branch : (body.branch || '')));
      const executive = String((p.executive != null ? p.executive : (body.executive || '')));
      const service = String((p.service != null ? p.service : (body.service || ''))).toLowerCase();
      const status = String((p.status != null ? p.status : (body.status || ''))).toLowerCase();
      const sinceISO = String((p.since != null ? p.since : (body.since || '')));
      const untilISO = String((p.until != null ? p.until : (body.until || '')));
      const startMs = p.start ? +p.start : (body.start ? +body.start : null);
      const endMs = p.end ? +p.end : (body.end ? +body.end : null);
      const q = String((p.q != null ? p.q : (body.q || '')));
      const page = Math.max(parseInt((p.page != null ? p.page : (body.page || '1')), 10) || 1, 1);
      const pageSize = Math.min(100, Math.max(0, parseInt((p.pageSize != null ? p.pageSize : (body.pageSize || body.pagesize || '0')), 10) || 0));
      const limit = Math.max(parseInt((p.limit != null ? p.limit : (body.limit || '0')), 10) || 0, 0);

      const resp = list_({
        branch, executive, service, status, sinceISO, untilISO, startMs, endMs,
        q,
        page, pageSize, limit
      });
      return json_(resp);
    }

    if (action === 'search') {
      const mode = ((e && e.parameter && e.parameter.mode) || body.mode || 'jc').toLowerCase();
      const query = String(((e && e.parameter && e.parameter.query) || body.query || ''));
      return json_( { success:true, rows: search_(mode, query) } );
    }

    if (action === 'getservicehistory') {
      const params = Object.assign({}, e && e.parameter ? e.parameter : {}, body);
      return json_(getServiceHistory_(params));
    }

    if (action === 'save') {
      const data = body.data || body;
      return json_(save_(data)); // upsert by mobile
    }

    if (action === 'postservice') {
      const data = body.data || body;
      return json_(postService_(data)); // upsert by mobile + DailyCollections
    }

    if (action === 'followups') {
      const filter = (((e && e.parameter && e.parameter.filter) || body.filter || 'today')+'').toLowerCase(); // today|overdue|upcoming|all
      const branch = String(((e && e.parameter && e.parameter.branch) || body.branch || ''));
      const executive = String(((e && e.parameter && e.parameter.executive) || body.executive || ''));
      return json_(followups_(filter, branch, executive));
    }

    if (action === 'updatefollowup') {
      const serialNo = String(((e && e.parameter && e.parameter.serialNo) || body.serialNo || ''));
      const patch = body.patch || {};
      return json_(updateFollowup_(serialNo, patch));
    }

    if (action === 'remark') {
      const jcNo = String(((e && e.parameter && e.parameter.jcNo) || body.jcNo || '')).trim();
      const level = String(((e && e.parameter && e.parameter.level) || body.level || '')).toLowerCase(); // ok|warning|alert
      const text = String(((e && e.parameter && e.parameter.text) || body.text || '')).trim();
      const by = String(((e && e.parameter && e.parameter.by) || body.by || '')).trim(); // optional
      return json_(updateRemark_(jcNo, level, text, by));
    }

    // Admin views for Daily Collections (uses master file)
    if (action === 'collections') {
      const p = e && e.parameter ? e.parameter : {};
      return json_(collections_({
        branch:   p.branch   || body.branch   || '',
        date:     p.date     || body.date     || '',
        page:     p.page     || body.page     || '1',
        pageSize: p.pageSize || body.pageSize || '10'
      }));
    }

    if (action === 'settle_collection') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const d = p.date   || body.date   || '';
      return json_(settleCollection_(b, s, d));
    }

    if (action === 'update_collection') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const d = p.date   || body.date   || '';
      const collectedToday = (p.collectedToday != null ? p.collectedToday : body.collectedToday);
      return json_(updateCollectionDC_({ date:d, branch:b, staff:s, collectedToday }));
    }

    if (action === 'staff_collection_summary') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      return json_(getStaffCollectionSummary_(b, s));
    }

    if (action === 'dc_test') {
      return json_(updateDailyCollection_('Muddinapalya','Rukmini',123,'jc'));
    }

    // ===== Staff Ledger (NEW endpoints) =====
    if (action === 'staff_ledger_summary') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      return json_(staffLedgerSummary_(b, s));
    }

    if (action === 'staff_ledger_transactions') {
      const p = e && e.parameter ? e.parameter : {};
      const b = p.branch || body.branch || '';
      const s = p.staff  || body.staff  || '';
      const mode = (p.mode || body.mode || 'all')+'';
      return json_(staffLedgerTransactions_(b, s, mode));
    }

    if (action === 'owner_ledger_list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const status = (p.status || body.status || 'unsettled')+'';
      const fromDate = p.fromDate || body.fromDate || '';
      const toDate = p.toDate || body.toDate || '';
      return json_(ownerLedgerList_({ branch, staff, status, fromDate, toDate }));
    }

    if (action === 'owner_ledger_settle') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const mode = (p.mode || body.mode || 'both')+'';
      const idsRaw = (p.ids || body.ids || '');
      const settledBy = p.settledBy || body.settledBy || 'OWNER';
      const ids = Array.isArray(idsRaw)
        ? idsRaw.map(x=>+x).filter(n=>Number.isFinite(n))
        : String(idsRaw||'').split(/[,\s]+/).map(x=>+x).filter(n=>Number.isFinite(n));
      const rv = staffLedgerSettleRows_(ids, mode, settledBy, { branch, staff });
      return json_({ success:true, updatedCount: rv.updatedCount||0 });
    }

    if (action === 'owner_prev_due_list') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      return json_(ownerPrevDueList_({ branch, staff }));
    }

    if (action === 'owner_prev_due_set') {
      const p = e && e.parameter ? e.parameter : {};
      const branch = p.branch || body.branch || '';
      const staff = p.staff || body.staff || '';
      const amount = (p.amount != null ? p.amount : (body.amount != null ? body.amount : undefined));
      const note = p.note != null ? p.note : body.note;
      const updatedBy = p.updatedBy || body.updatedBy || 'OWNER';
      return json_(ownerPrevDueSet_(branch, staff, amount, note, updatedBy));
    }

    return json_({
      ok:true,
      hint:'actions: list, nextSerial, search, save, postService, followups, updateFollowup, remark, collections, update_collection, settle_collection, staff_collection_summary, dc_test'
    });
  }catch(err){
    return json_({ success:false, error:String(err) });
  }
}

function json_(o){
  return ContentService.createTextOutput(JSON.stringify(o))
    .setMimeType(ContentService.MimeType.JSON);
}

function sh_(){
  const ss = JOBCARD_SHEET_ID ? openSpreadsheet(JOBCARD_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
  return ensureSheetWithHeader(ss, JOBCARD_SHEET_NAME, DEFAULT_HEADERS);
}

function norm_(s){ return String(s || '').trim().toLowerCase(); }
function normReg_(s){ return String(s || '').toUpperCase().replace(/\s+/g,''); }

function headerIx_(s){
  const width = Math.max(s.getLastColumn(), DEFAULT_HEADERS.length);
  const H = s.getRange(1,1,1,width).getValues()[0].map(x => String(x||'').trim());

  const pos = (rx) => H.findIndex(h => rx.test(h));
  const posAll = (rx) => H.map((h,i)=>rx.test(h)?i:-1).filter(i=>i>=0);

  return {
    headers: H, width,
    idxTime: pos(/^(timestamp|created\s*at|submitted|submission)/i),
    idxName: pos(/(customer[\s_]*name|^name$)/i),
    idxMobile: pos(/(mobile|phone)/i),
    idxAmount: pos(/collected[\s_]*amount/i),
    idxReg: pos(/(vehicle[\s_]*no|registration|^reg(?:[\s_]*no)?$)/i),
    idxSvc: pos(/service[\s_]*type/i),
    idxBranch: pos(/^branch$/i),
    idxObs: pos(/(customer[\s_]*ob(?:s|servation)|observation)/i),
    idxExp: pos(/expected[\s_]*delivery/i),
    idxPayloads: posAll(/^payload$/i),
    idxPayment: pos(/^payment/i),
    idxJC: pos(/^(jc\b|job[\s_]*card)/i),
    // optional extra columns
    idxRemarkLevel: pos(/remark.*level/i),
    idxRemarkText: pos(/remark.*text/i),
    idxExecutive2: pos(/^executive$/i),
    idxMechanic: pos(/(allotted[\s_]mechanic|mechanic)$/i),
    idxModel: pos(/^model$/i),
    idxColour: pos(/^(colour|color)$/i),
    idxKM: pos(/^(odometer.|km)$/i),
    idxFuel: pos(/^fuel[\s_]*level$/i),
    idxVehType: pos(/vehicle[\s_]*type/i),
    idxPostAt: pos(/^(post[\s_]*service[\s_]*at|post[\s_]serviced[\s_]at)$/i),
    idxUTR: pos(/^(utr(\sno|\snumber)?)/i),
  };
}

function ensureRemarkCols_(s, info){
  let ix = info || headerIx_(s);
  if (ix.idxRemarkLevel < 0) {
    s.getRange(1, ix.headers.length + 1).setValue('RemarkLevel');
    ix = headerIx_(s);
  }
  if (ix.idxRemarkText < 0) {
    s.getRange(1, ix.headers.length + 1).setValue('RemarkText');
    ix = headerIx_(s);
  }
  return ix;
}

function ensureCol_(s, name){
  const info = headerIx_(s);
  if (info.headers.indexOf(name) >= 0) return info;
  s.getRange(1, info.headers.length + 1).setValue(name);
  return headerIx_(s);
}

function ensureCoreOptionalCols_(s){
  let ix = headerIx_(s);
  ['Executive','Allotted Mechanic','Model','Colour','Odometer Reading','Fuel Level','Vehicle Type','Post Service At','UTR No']
    .forEach((col) => { ix = ensureCol_(s, col); });
  return ix;
}

function nextSerial_(){
  const s = sh_(), ix = headerIx_(s);
  if (ix.idxJC < 0) return '1';
  const last = s.getLastRow();
  if (last <= 1) return '1';
  const vals = s.getRange(2, ix.idxJC+1, last-1, 1)
    .getValues()
    .map(r => parseInt(String(r[0]).trim(),10))
    .filter(n => Number.isFinite(n));
  return String((vals.length ? Math.max.apply(null, vals) : 0) + 1);
}

function ten_(x){ return String(x||'').replace(/\D/g,'').slice(-10); }
function safeJson_(x){ try{return JSON.parse(String(x||'{}'))}catch(_){return null} }

function cleanPayload_(rawPayload, fv){
  if (!rawPayload || typeof rawPayload !== 'object') return {};
  const std = new Set([
    'custName','custMobile','amount','paymentMode',
    'regNo','serviceType','branch','obs','expectedDelivery','jcNo'
  ]);
  const out = JSON.parse(JSON.stringify(rawPayload));
  if (out.formValues && typeof out.formValues === 'object') {
    Object.keys(out.formValues).forEach(k => { if (std.has(k)) delete out.formValues[k]; });
  }
  Object.keys(out).forEach(k => { if (std.has(k)) delete out[k]; });
  return out;
}

/* ===== Robust amount + mode helpers ===== */
function computeAmount_(d){
  try{
    if (Array.isArray(d.payments) && d.payments.length) {
      const total = d.payments.reduce((acc, p) => acc + (Number(p.amount)||0), 0);
      if (total > 0) return total;
    }
    const tgRoot = Number(d?.totals?.grand || 0);
    if (tgRoot > 0) return tgRoot;
    const tgPayload = Number(d?.payload?.totals?.grand || 0);
    if (tgPayload > 0) return tgPayload;
    const ca = Number(d?.collectedAmount || 0);
    if (ca > 0) return ca;
    const fvAmt = Number(d?.formValues?.amount || 0);
    if (fvAmt > 0) return fvAmt;
    return 0;
  }catch(_){ return 0; }
}

function computeMode_(d){
  try{
    if (Array.isArray(d.payments) && d.payments.length) {
      const modes = d.payments
        .map(p => String(p.mode||'').trim().toLowerCase())
        .filter(Boolean);
      const uniq = Array.from(new Set(modes));
      if (uniq.length === 1) return uniq[0];
      if (uniq.length > 1) return 'mixed';
    }
    if (d.paymentMode) return String(d.paymentMode).toLowerCase();
    if (d.formValues && d.formValues.paymentMode) return String(d.formValues.paymentMode).toLowerCase();
    return '';
  }catch(_){ return ''; }
}

/* ============ Service History (append-only; keyed by jcNo) ============ */
function serviceHistorySheet_(){
  const ss = JOBCARD_SHEET_ID ? openSpreadsheet(JOBCARD_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(SERVICE_HISTORY_SHEET);
  if (!sh) {
    sh = ss.insertSheet(SERVICE_HISTORY_SHEET);
    sh.appendRow(SERVICE_HISTORY_HEADERS);
  }
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const first = sh.getRange(1,1,1,width).getValues()[0];
  const hasAny = first.some(v => String(v||'').trim());
  if (!hasAny) {
    sh.getRange(1,1,1,SERVICE_HISTORY_HEADERS.length).setValues([SERVICE_HISTORY_HEADERS]);
  }
  return sh;
}

function serviceHistoryIx_(headers){
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  const find = (name) => H.indexOf(norm(name));
  return {
    CreatedAt: find('created at'),
    PostAt: find('post service at'),
    JCNo: find('jc no'),
    RegNo: find('reg no'),
    Mobile: find('mobile'),
    CustName: find('customer name'),
    Branch: find('branch'),
    ServiceType: find('service type'),
    VehicleType: find('vehicle type'),
    Model: find('model'),
    Colour: find('colour'),
    Mechanic: find('mechanic'),
    Executive: find('executive'),
    ServiceNo: find('service no'),
    KM: find('km'),
    Fuel: find('fuel level'),
    PaymentMode: find('payment mode'),
    CollectedAmount: find('collected amount'),
    TotalsGrand: find('totals grand'),
    WorkDone: find('work done'),
    Remarks: find('remarks'),
    CustObs: find('customer observation'),
    PaymentsJson: find('payments json'),
    PayloadJson: find('payload json'),
    width: headers.length
  };
}

function ensureServiceHistoryCol_(sh, name){
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const headers = sh.getRange(1,1,1,width).getValues()[0];
  if (headers.indexOf(name) >= 0) return;
  sh.getRange(1, headers.length + 1).setValue(name);
}

function upsertServiceHistory_(d){
  try{
    const jcNo = String(d?.jcNo || d?.formValues?.jcNo || d?.payload?.formValues?.jcNo || '').trim();
    if (!jcNo) return { success:false, message:'jcNo missing' };
    const sh = serviceHistorySheet_();
    ensureServiceHistoryCol_(sh, 'Customer Observation');
    const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
    const headers = sh.getRange(1,1,1,width).getValues()[0];
    const I = serviceHistoryIx_(headers);
    const last = sh.getLastRow();
    const rows = (last > 1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];

    const regNo = normReg_(d?.regNo || d?.formValues?.regNo || d?.payload?.formValues?.regNo || d?.payload?.regNo || '');
    const mobile = ten_(d?.mobile || d?.formValues?.custMobile || d?.payload?.formValues?.custMobile || d?.payload?.mobile || '');
    const custName = d?.custName || d?.formValues?.custName || d?.payload?.formValues?.custName || '';
    const branch = d?.branch || d?.formValues?.branch || d?.payload?.formValues?.branch || '';
    const serviceType = d?.serviceType || d?.formValues?.serviceType || d?.payload?.formValues?.serviceType || '';
    const vehicleType = d?.vehicleType || d?.formValues?.vehicleType || d?.payload?.formValues?.vehicleType || '';
    const model = d?.model || d?.formValues?.model || d?.payload?.formValues?.model || '';
    const colour = d?.colour || d?.color || d?.formValues?.colour || d?.formValues?.color || d?.payload?.formValues?.colour || d?.payload?.formValues?.color || '';
    const mechanic = d?.mechanic || d?.formValues?.mechanic || d?.payload?.formValues?.mechanic || '';
    const executive = d?.executive || d?.formValues?.executive || d?.payload?.formValues?.executive || '';
    const km = d?.km || d?.formValues?.km || d?.payload?.formValues?.km || '';
    const fuelLevel = d?.fuelLevel || d?.formValues?.fuelLevel || d?.payload?.formValues?.fuelLevel || '';
    const paymentMode = computeMode_(d) || d?.paymentMode || d?.formValues?.paymentMode || d?.payload?.formValues?.paymentMode || '';
    const amount = computeAmount_(d) || d?.collectedAmount || d?.formValues?.amount || d?.payload?.collectedAmount || d?.payload?.totals?.grand || '';
    const totalsGrand = d?.totals?.grand || d?.payload?.totals?.grand || amount || '';
    const postServiceAt = d?.postServiceAt || d?.payload?.postServiceAt || '';
    const createdAt = d?.createdAt || d?.timestamp || d?.ts || d?.payload?.createdAt || postServiceAt || new Date().toISOString();
  const remarkText =
    d?.remark ||
    d?.remarks ||
    d?.formValues?.remarks ||
    d?.payload?.remarks ||
    (d?.payload?.remark && d.payload.remark.text) ||
    d?.payload?.formValues?.remarks ||
    '';
    const custObs =
      d?.obs ||
      d?.formValues?.obs ||
      d?.payload?.obs ||
      d?.payload?.formValues?.obs ||
      '';
    
    const paymentsJson = JSON.stringify(d?.payments || d?.payload?.payments || []);
    const payloadJson = JSON.stringify(d || {});
    const workDone = Array.isArray(d?.labourRows || d?.payload?.labourRows)
      ? (d.labourRows || d.payload.labourRows)
          .map(r => r?.item || r?.Item || r?.Description || r?.desc || '')
          .filter(Boolean)
          .join(', ')
      : '';

    let existing = null;
    for (let i = rows.length - 1; i >= 0; i--) {
      const jc = String(rows[i][I.JCNo] || '').trim();
      if (jc && jc.toUpperCase() === jcNo.toUpperCase()) {
        existing = { row: i + 2, values: rows[i] };
        break;
      }
    }
    const regCount = regNo ? rows.filter(r => normReg_(r[I.RegNo]) === regNo).length : 0;
    const serviceNo = existing
      ? (Number(rows[existing.row - 2][I.ServiceNo]) || regCount || 1)
      : (regCount + 1);

    const row = new Array(I.width).fill('');
    const put = (idx, val) => { if (idx >= 0) row[idx] = (val === undefined || val === null) ? '' : val; };
    put(I.CreatedAt, createdAt);
    put(I.PostAt, postServiceAt || createdAt);
    put(I.JCNo, jcNo);
    put(I.RegNo, regNo);
    put(I.Mobile, mobile);
    put(I.CustName, custName);
    put(I.Branch, branch);
    put(I.ServiceType, serviceType);
    put(I.VehicleType, vehicleType);
    put(I.Model, model);
    put(I.Colour, colour);
    put(I.Mechanic, mechanic);
    put(I.Executive, executive);
    put(I.ServiceNo, serviceNo);
    put(I.KM, km);
    put(I.Fuel, fuelLevel);
    put(I.PaymentMode, paymentMode);
    put(I.CollectedAmount, amount);
    put(I.TotalsGrand, totalsGrand);
    put(I.WorkDone, workDone);
    put(I.Remarks, remarkText);
    put(I.CustObs, custObs);
    put(I.PaymentsJson, paymentsJson);
    put(I.PayloadJson, payloadJson);

    if (existing) {
      sh.getRange(existing.row,1,1,row.length).setValues([row]);
      return { success:true, updated:true, serviceNo };
    }
    sh.appendRow(row);
    return { success:true, inserted:true, serviceNo };
  }catch(err){
    return { success:false, message:String(err) };
  }
}

function serviceHistoryRowToObj_(r, I){
  const payloadRaw = safeJson_(r[I.PayloadJson]) || {};
  const payments = safeJson_(r[I.PaymentsJson]) || [];
  const regNo = r[I.RegNo] || '';
  const jcNo = r[I.JCNo] || '';
  const mobile = r[I.Mobile] || '';
  const serviceType = r[I.ServiceType] || '';
  const model = r[I.Model] || '';
  const colour = r[I.Colour] || '';
  const branch = r[I.Branch] || '';
  const mechanic = r[I.Mechanic] || '';
  const executive = r[I.Executive] || '';
  const serviceNo = Number(r[I.ServiceNo] || '') || null;
  const createdAt = r[I.PostAt] || r[I.CreatedAt] || '';
  const remarks = r[I.Remarks] || '';
  const amount = r[I.CollectedAmount] || r[I.TotalsGrand] || '';
  const paymentMode = r[I.PaymentMode] || '';

  const totals = payloadRaw.totals || {};
  if (!totals.grand && amount) totals.grand = Number(amount) || amount;
  payloadRaw.totals = totals;
  payloadRaw.payments = payloadRaw.payments || payments;
  const fv = payloadRaw.formValues || {};
  payloadRaw.formValues = Object.assign({}, fv, {
    regNo,
    jcNo,
    serviceType,
    model,
    colour,
    branch,
    mechanic,
    executive,
    paymentMode,
    custMobile: mobile,
    createdAt,
    serviceNo
  });
  payloadRaw.serviceNo = serviceNo;

  return {
    jcNo,
    regNo,
    mobile,
    serviceType,
    model,
    colour,
    branch,
    mechanic,
    executive,
    amount,
    paymentMode,
    serviceNo,
    createdAt,
    remarks,
    totals,
    payments,
    payload: payloadRaw,
    values: {
      'JC No': jcNo,
      'Vehicle No': regNo,
      'Registration Number': regNo,
      'Service Type': serviceType,
      'Model': model,
      'Colour': colour,
      'Branch': branch,
      'Mechanic': mechanic,
      'Executive': executive,
      'Payment Mode': paymentMode,
      'Collected Amount': amount,
      'Created At': createdAt,
      'Remark Text': remarks,
      'Service No': serviceNo,
    }
  };
}

function getServiceHistory_(params){
  const q = String(params && (params.query || params.regNo || params.vehicle || params.mobile || params.number) || '').trim();
  if (!q) return { success:false, message:'query (vehicle or mobile) is required' };
  const regQ = normReg_(q);
  const mobileQ = ten_(q);
  const sh = serviceHistorySheet_();
  const width = Math.max(sh.getLastColumn(), SERVICE_HISTORY_HEADERS.length);
  const headers = sh.getRange(1,1,1,width).getValues()[0];
  const I = serviceHistoryIx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:true, rows: [] };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const matches = rows
    .filter(r => {
      const regMatch = regQ ? normReg_(r[I.RegNo]) === regQ : false;
      const mobileMatch = mobileQ ? ten_(r[I.Mobile]) === mobileQ : false;
      return regMatch || mobileMatch;
    })
    .map(r => serviceHistoryRowToObj_(r, I))
    .sort((a,b) => {
      const ta = a.createdAt ? new Date(a.createdAt).getTime() : 0;
      const tb = b.createdAt ? new Date(b.createdAt).getTime() : 0;
      if (ta !== tb) return ta - tb;
      const sa = Number(a.serviceNo || 0);
      const sb = Number(b.serviceNo || 0);
      return sa - sb;
    });
  return { success:true, rows: matches };
}

/** Upsert by JC No (fallback to mobile if JC is missing). */
function upsertByMobile_(d){
  const lock = LockService.getScriptLock();
  try {
    lock.waitLock(30000);
  } catch (e) {
    return { success:false, message:'lock_timeout' };
  }
  try {
    const s = sh_();
    ensureCoreOptionalCols_(s);
    let ix = headerIx_(s);

  const fvIncoming = d.formValues || {};
  const jcIncoming = String(
    d.jcNo ||
    fvIncoming.jcNo ||
    (d.payload && d.payload.formValues && d.payload.formValues.jcNo) ||
    ''
  ).trim();
  const mobile10 = ten_(d.mobile || fvIncoming.custMobile);
  const last = s.getLastRow();
  let hitRow = -1;
  let existingRow = null;
  if (last > 1) {
    const rows = s.getRange(2,1,last-1,ix.width).getValues();
    if (jcIncoming && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const jc = String(rows[i][ix.idxJC] || '').trim();
        if (jc && jc === jcIncoming) { hitRow = i + 2; existingRow = rows[i]; break; }
      }
    }
    if (hitRow < 0 && !jcIncoming && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const m = ten_(rows[i][ix.idxMobile]);
        if (m === mobile10) { hitRow = i + 2; existingRow = rows[i]; break; }
      }
    }
  }

  if (hitRow < 0) {
    return insertNew_(Object.assign({}, d, { formValues: fvIncoming, payload: d.payload || d }), mobile10);
  }

  const existingPayload = (existingRow && ix.idxPayloads.length) ? safeJson_(existingRow[ix.idxPayloads[0]]) : null;
  const existingFv = existingPayload && existingPayload.formValues ? existingPayload.formValues : {};
  const fv = Object.assign({}, existingFv || {}, fvIncoming || {});

  const put = (row, i, v) => { if (i >= 0 && v !== undefined && v !== null && String(v) !== '') row[i] = v; };
  const digits = (s) => String(s||'').replace(/\D/g,'');

  let mergedPayload = {};
  if (existingPayload && typeof existingPayload === 'object') mergedPayload = JSON.parse(JSON.stringify(existingPayload));
  if (d.payload && typeof d.payload === 'object') mergedPayload = mergeObj_(mergedPayload, d.payload);
  mergedPayload.formValues = Object.assign({}, existingFv || {}, fvIncoming || {});

  const postAt = (mergedPayload && mergedPayload.postServiceAt) ? mergedPayload.postServiceAt : (d?.payload?.postServiceAt || '');
  const utr = String(d && (d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '')).trim();

  const row = s.getRange(hitRow,1,1,ix.width).getValues()[0];

  put(row, ix.idxTime, new Date());
  put(row, ix.idxName, fv.custName);
  put(row, ix.idxMobile, mobile10);
  put(row, ix.idxAmount, (d.collectedAmount != null ? d.collectedAmount : fv.amount));
  put(row, ix.idxReg, fv.regNo);
  put(row, ix.idxSvc, fv.serviceType);
  put(row, ix.idxBranch, fv.branch);
  put(row, ix.idxObs, fv.obs);
  put(row, ix.idxExp, fv.expectedDelivery);
  put(row, ix.idxPayment, (d.paymentMode != null ? d.paymentMode : fv.paymentMode));

  put(row, ix.idxExecutive2, fv.executive);
  put(row, ix.idxMechanic, fv.mechanic);
  put(row, ix.idxModel, fv.model);
  put(row, ix.idxColour, fv.colour);
  put(row, ix.idxKM, digits(fv.km));
  put(row, ix.idxFuel, fv.fuelLevel);
  put(row, ix.idxVehType, fv.vehicleType);

  put(row, ix.idxPostAt, postAt);
  put(row, ix.idxUTR, utr);

  if (ix.idxJC >= 0 && (d.jcNo || fv.jcNo)) row[ix.idxJC] = (d.jcNo || fv.jcNo);

  if (ix.idxPayloads.length) row[ix.idxPayloads[0]] = JSON.stringify(mergedPayload);

    s.getRange(hitRow,1,1,ix.width).setValues([row]);
    return { success:true, upsert:true, updated:true, row: hitRow };
  } finally {
    try { lock.releaseLock(); } catch (_) {}
  }
}

function insertNew_(d, mobileCanonical){
  const s = sh_();
  ensureCoreOptionalCols_(s);
  let ix = headerIx_(s);

  const fv = d.formValues || {};
  const serial = String(fv.jcNo || nextSerial_());
  const mobile10 = mobileCanonical || ten_(fv.custMobile);

  const put = (row, i, v) => { if (i >= 0) row[i] = (v === undefined || v === null) ? '' : v; };
  const digits = (s) => String(s||'').replace(/\D/g,'');

  const postAt = (d && d.payload && d.payload.postServiceAt) ? d.payload.postServiceAt : '';
  const utr = String(d && (d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '')).trim();

  const row = new Array(ix.width).fill('');
  put(row, ix.idxTime, new Date());
  put(row, ix.idxName, fv.custName || '');
  put(row, ix.idxMobile, mobile10 || '');
  put(row, ix.idxAmount, (d.collectedAmount != null ? d.collectedAmount : fv.amount) || '');
  put(row, ix.idxReg, fv.regNo || '');
  put(row, ix.idxSvc, fv.serviceType || '');
  put(row, ix.idxBranch, fv.branch || '');
  put(row, ix.idxObs, fv.obs || '');
  put(row, ix.idxExp, fv.expectedDelivery || '');
  put(row, ix.idxPayment, (d.paymentMode != null ? d.paymentMode : fv.paymentMode) || '');

  put(row, ix.idxExecutive2, fv.executive || '');
  put(row, ix.idxMechanic, fv.mechanic || '');
  put(row, ix.idxModel, fv.model || '');
  put(row, ix.idxColour, fv.colour || '');
  put(row, ix.idxKM, digits(fv.km || ''));
  put(row, ix.idxFuel, fv.fuelLevel || '');
  put(row, ix.idxVehType, fv.vehicleType || '');

  put(row, ix.idxPostAt, postAt || '');
  put(row, ix.idxUTR, utr || '');

  const payloadToStore = (function(){
    const base = (d && d.payload && typeof d.payload === 'object') ? d.payload : {};
    const merged = mergeObj_({ formValues: {} }, base);
    merged.formValues = Object.assign({}, fv || {});
    return merged;
  })();
  if (ix.idxPayloads.length) row[ix.idxPayloads[0]] = JSON.stringify(payloadToStore);

  put(row, ix.idxJC, serial);

  s.appendRow(row);
  return { success:true, upsert:true, row: s.getLastRow(), jcNo: serial };
}

/* === NEW: fetch full existing row & payload for delta DC logic === */
function findExistingRowFull_(mobile10, jcNo){
  try{
    const s = sh_();
    const ix = headerIx_(s);
    const last = s.getLastRow();
    if (last <= 1) return null;

    const rows = s.getRange(2,1,last-1,ix.width).getValues();
  if (jcNo && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--){
        const r = rows[i];
        const jc = String(r[ix.idxJC] || '').trim();
        if (jc && jc === jcNo){
          const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
          return { rowIndex: i+2, rowValues: r, payload, ix };
        }
      }
    }
    if (!jcNo && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--){
        const r = rows[i];
        const m = ten_(r[ix.idxMobile]);
        if (m === mobile10){
          const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
          return { rowIndex: i+2, rowValues: r, payload, ix };
        }
      }
    }
    return null;
  }catch(_){ return null; }
}

/* === helper to fetch branch + executive from existing sheet row === */
function findExistingBranchExec_(mobile10, jcNo) {
  try {
    const s = sh_();
    const ix = headerIx_(s);
    const last = s.getLastRow();
    if (last <= 1) return { branch: '', executive: '' };

    const rows = s.getRange(2,1,last-1,ix.width).getValues();
    let hit = -1;
    if (jcNo && ix.idxJC >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const r = rows[i];
        const jc = String(r[ix.idxJC] || '').trim();
        if (jc && jc === jcNo) { hit = i; break; }
      }
    }
    if (hit < 0 && mobile10 && ix.idxMobile >= 0) {
      for (let i = rows.length - 1; i >= 0; i--) {
        const r = rows[i];
        const m = String(r[ix.idxMobile] || '').replace(/\D/g,'').slice(-10);
        if (m === mobile10) { hit = i; break; }
      }
    }
    if (hit < 0) return { branch: '', executive: '' };

    const r = rows[hit];
    let branch = String(r[ix.idxBranch] || '').trim();
    let executive = ix.idxExecutive2 >= 0 ? String(r[ix.idxExecutive2] || '').trim() : '';

    if (!branch || !executive) {
      const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;
      if (!branch)    branch    = String(payload?.formValues?.branch    || '').trim();
      if (!executive) executive = String(payload?.formValues?.executive || '').trim();
    }
    return { branch, executive };
  } catch (_) { 
    return { branch: '', executive: '' }; 
  }
}

// save (pre-service) ‚Üí upsert by mobile
function save_(d){
  return upsertByMobile_({ ...d, payload: d.payload || d });
}

// postService ‚Üí upsert by mobile with amount/payment overrides + DailyCollections update
function postService_(d){
  const amount = computeAmount_(d);
  const mode = computeMode_(d);

  const nowIso = new Date().toISOString();
  const payload0 = (d.payload && typeof d.payload === 'object') ? d.payload : {};
  if (!payload0.postServiceAt) payload0.postServiceAt = nowIso;

  const mobile10 =
    String(d.mobile || d?.formValues?.custMobile || d?.payload?.formValues?.custMobile || '')
      .replace(/\D/g,'')
      .slice(-10);
  const jcNo = String(d.jcNo || d?.formValues?.jcNo || d?.payload?.formValues?.jcNo || '').trim();

  // ‚úÖ NEW: grab previous service amount & logged-state BEFORE update
  const existingFull = findExistingRowFull_(mobile10, jcNo);
  const prevPayload = existingFull?.payload || {};
  const prevAmt = Number(prevPayload?.postServiceAmount || existingFull?.rowValues?.[existingFull.ix.idxAmount] || 0) || 0;
  const alreadyLogged = prevPayload?.postServiceLogged === true;

  const fv0 = d.formValues || {};
  let branch    = fv0.branch    || d?.payload?.formValues?.branch    || '';
  let executive = fv0.executive || d?.payload?.formValues?.executive || '';

  if ((!branch || !executive) && (mobile10 || jcNo)) {
    const got = findExistingBranchExec_(mobile10, jcNo);
    if (!branch)    branch    = got.branch;
    if (!executive) executive = got.executive;
  }

  const fv = {
    ...fv0,
    branch,
    executive,
    amount: (amount > 0 ? amount : fv0.amount),
    paymentMode: (mode || fv0.paymentMode || ''),
    jcNo: jcNo || fv0.jcNo
  };

  // ‚úÖ NEW: store flags so next postservice won't double count
  payload0.postServiceLogged = true;
  payload0.postServiceAmount = amount;
  payload0.postServiceMode = mode;

  // 1) Save/update main Job Card row
  const result = upsertByMobile_({
    ...d,
    collectedAmount: amount,
    paymentMode: mode,
    formValues: fv,
    payload: payload0
  });

  // 1b) Append to ServiceHistory (jcNo idempotent)
  try {
    upsertServiceHistory_({
      ...d,
      formValues: fv,
      payload: payload0,
      totals: { ...(d.totals || {}), grand: amount },
      collectedAmount: amount,
      postServiceAt: payload0.postServiceAt || nowIso
    });
  } catch (_){}

  // 2) Update DailyCollections for this JC amount (with split)
  try {
    const b = String(fv.branch || '').trim();
    const s = String(fv.executive || '').trim();
    const newAmt = Number(amount || 0);

    // ‚úÖ NEW: delta logic
    const deltaAmt = alreadyLogged ? Math.max(0, newAmt - prevAmt) : newAmt;
    if (!(deltaAmt > 0)) return result; // nothing extra to log

    let cashCollected = Number(d.cashCollected || 0) || 0;
    let onlineCollected = Number(d.onlineCollected || 0) || 0;

    if (!(cashCollected > 0) && !(onlineCollected > 0) && Array.isArray(d.payments)) {
      cashCollected = d.payments
        .filter(p => String(p.mode||'').toLowerCase()==='cash')
        .reduce((sum,p)=> sum + (Number(p.amount)||0), 0);
      onlineCollected = d.payments
        .filter(p => String(p.mode||'').toLowerCase()==='online')
        .reduce((sum,p)=> sum + (Number(p.amount)||0), 0);
    }

    if (!(cashCollected > 0) && !(onlineCollected > 0) && deltaAmt > 0) {
      if (mode === 'cash') cashCollected = deltaAmt;
      else if (mode === 'online') onlineCollected = deltaAmt;
      else cashCollected = deltaAmt;
    }

    if (b && s && deltaAmt > 0) {
      const ledgerCtx = {
        sourceType: 'jc',
        sourceId: jcNo,
        jcNo: jcNo,
        customerName: fv.custName || fv.customerName || '',
        customerMobile: mobile10,
        paymentMode: mode || fv.paymentMode || '',
        payments: Array.isArray(d.payments) ? d.payments : undefined,
        utr: String(d.utr || d.utrNo || (d.payload && (d.payload.utr || d.payload.utrNo)) || '').trim()
      };
      updateDailyCollection_(b, s, deltaAmt, 'jc', { cashCollected, onlineCollected, staffLedgerContext: ledgerCtx });
    }
  } catch (err) {}

  return result;
}

// Produce a normalized object for one sheet row
function toRowObject_(row, ix){
  const payload = ix.idxPayloads.length ? safeJson_(row[ix.idxPayloads[0]]) : null;

  const pr = payload && payload.remark ? payload.remark : null;
  const levelFromCols = (ix.idxRemarkLevel >= 0) ? String(row[ix.idxRemarkLevel] || '') : '';
  const textFromCols = (ix.idxRemarkText >= 0) ? String(row[ix.idxRemarkText] || '') : '';
  const remarkLevel = pr && pr.level ? pr.level : levelFromCols;
  const remarkText = pr && pr.text ? pr.text : textFromCols;

  return {
    values: {
      Timestamp: row[ix.idxTime],
      Customer_Name: row[ix.idxName],
      Mobile: row[ix.idxMobile],
      Collected_Amount: row[ix.idxAmount],
      Vehicle_No: row[ix.idxReg],
      Service_Type: row[ix.idxSvc],
      Branch: row[ix.idxBranch],
      Customer_Observation: row[ix.idxObs],
      Expected_Delivery_Date: row[ix.idxExp],
      Payment_Mode: ix.idxPayment >= 0 ? row[ix.idxPayment] : '',
      'JC No.': row[ix.idxJC],
      RemarkLevel: remarkLevel || '',
      RemarkText: remarkText || '',
      Executive: ix.idxExecutive2 >= 0 ? row[ix.idxExecutive2] : '',
      Allotted_Mechanic: ix.idxMechanic >= 0 ? row[ix.idxMechanic] : '',
      Model: ix.idxModel >= 0 ? row[ix.idxModel] : '',
      Colour: ix.idxColour >= 0 ? row[ix.idxColour] : '',
      KM: ix.idxKM >= 0 ? row[ix.idxKM] : '',
      Fuel_Level: ix.idxFuel >= 0 ? row[ix.idxFuel] : '',
      Vehicle_Type: ix.idxVehType >= 0 ? row[ix.idxVehType] : '',
      Post_Service_At: ix.idxPostAt >= 0 ? row[ix.idxPostAt] : '',
      UTR_No: ix.idxUTR >= 0 ? row[ix.idxUTR] : '',
    },
    payload
  };
}

// Search by JC or Mobile
function search_(mode, query){
  const s = sh_();
  const ix = ensureRemarkCols_(s, headerIx_(s));
  const last = s.getLastRow();
  if (last <= 1) return [];

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  const q = String(query || '').trim();
  const q10 = ten_(q);
  const qReg = normReg_(q);

  const out = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;

    let match = false;
    if (mode === 'mobile') {
      const m = ten_(r[ix.idxMobile]);
      match = q10 ? (q10.length < 10 ? m.endsWith(q10) : (m === q10)) : false;
    } else if (mode === 'reg' || mode === 'vehicle') {
      const regSheet = ix.idxReg >= 0 ? normReg_(r[ix.idxReg]) : '';
      const regPayload = normReg_(payload && (
        payload.regNo ||
        payload.vehicleNo ||
        (payload.formValues && payload.formValues.regNo) ||
        (payload.formValues && payload.formValues.vehicleNo) ||
        (payload.vehicle && payload.vehicle.regNo) ||
        (payload.vehicle && payload.vehicle.registrationNumber)
      ));
      match = qReg ? (regSheet === qReg || regPayload === qReg) : false;
    } else {
      match = String(r[ix.idxJC] || '').trim() === q;
    }
    if (!match) continue;

    out.push(toRowObject_(r, ix));
  }
  return out;
}

/* ============================
Follow-up listing + updates
============================ */

function startOfToday_(){
  const d = new Date();
  d.setHours(0,0,0,0);
  return d;
}
function endOfToday_(){
  const d = new Date();
  d.setHours(23,59,59,999);
  return d;
}
function isValidDate_(d){ return d && Object.prototype.toString.call(d) === '[object Date]' && !isNaN(d.getTime()); }

function followups_(filter, branch, executive){
  const s = sh_();
  const ix = headerIx_(s);
  const last = s.getLastRow();
  if (last <= 1) return { success:true, rows: [] };

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  const t0 = startOfToday_().getTime();
  const t1 = endOfToday_().getTime();

  const want = String(filter || 'today').toLowerCase();
  const wantBranchKey = norm_(branch);
  const wantExecKey = norm_(executive);

  const out = [];
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    const jc = String(r[ix.idxJC] || '').trim();
    if (!jc) continue;

    const payload = ix.idxPayloads.length ? safeJson_((r[ix.idxPayloads[0]] || '{}')) : null;
    const fu = payload && payload.followUp ? payload.followUp : null;
    if (!fu || fu.enabled === false) continue;

    const at = fu.at ? new Date(fu.at) : null;
    const t = isValidDate_(at) ? at.getTime() : null;

    const rowBranch = String(fu.branch || r[ix.idxBranch] || '').trim();
    const execPayload = payload && payload.formValues ? String(payload.formValues.executive || '') : '';
    const rowExec = String(execPayload || fu.assignedTo || '').trim();

    if (wantBranchKey && norm_(rowBranch) !== wantBranchKey) continue;
    if (wantExecKey && norm_(rowExec) !== wantExecKey) continue;

    let datePass = true;
    if (want !== 'all') {
      if (!t) datePass = false;
      else if (want === 'today') datePass = (t >= t0 && t <= t1);
      else if (want === 'overdue') datePass = (t < t0);
      else if (want === 'upcoming')datePass = (t > t1);
    }
    if (!datePass) continue;

    const fvFromSheet = {
      name: String(r[ix.idxName] || '').trim(),
      mobile: String(r[ix.idxMobile] || '').trim(),
      branch: rowBranch,
      jcNo: jc,
      model: payload && payload.formValues ? (payload.formValues.model || '') : '',
      bikeModel: payload && payload.formValues ? (payload.formValues.model || '') : '',
      executive: rowExec,
    };

    out.push({
      formValues: fvFromSheet,
      followUp: {
        enabled: (fu.enabled !== false),
        at: fu.at || null,
        notes: fu.notes || '',
        assignedTo: rowExec || '',
        branch: rowBranch || '',
        customer: fu.customer || { name: fvFromSheet.name, mobile: fvFromSheet.mobile },
        status: fu.status || 'pending',
      },
      brand: (payload && payload.brand) ? payload.brand : '',
    });
  }

  out.sort((a,b) => {
    const ta = a.followUp.at ? new Date(a.followUp.at).getTime() : 0;
    const tb = b.followUp.at ? new Date(b.followUp.at).getTime() : 0;
    return tb - ta;
  });

  return { success:true, rows: out };
}

function mergeObj_(target, src){
  if (!src || typeof src !== 'object') return target || {};
  if (!target || typeof target !== 'object') target = {};
  Object.keys(src).forEach(k => {
    const v = src[k];
    if (v && typeof v === 'object' && !Array.isArray(v)) {
      target[k] = mergeObj_(target[k], v);
    } else {
      target[k] = v;
    }
  });
  return target;
}

function updateFollowup_(serialNo, patch){
  if (!serialNo) return { success:false, message:'serialNo is required' };
  const s = sh_();
  const ix = headerIx_(s);
  if (ix.idxJC < 0) return { success:false, message:'JC column not found' };
  if (!ix.idxPayloads.length) return { success:false, message:'Payload column not found' };

  const last = s.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  const rows = s.getRange(2,1,last-1,ix.width).getValues();
  let hit = -1;
  for (let i = rows.length - 1; i >= 0; i--) {
    const jc = String(rows[i][ix.idxJC] || '').trim();
    if (jc === String(serialNo).trim()) { hit = i + 2; break; }
  }
  if (hit < 0) return { success:false, message:'Not found' };

  const row = s.getRange(hit,1,1,ix.width).getValues()[0];
  const cur = safeJson_(row[ix.idxPayloads[0]]) || {};
  cur.followUp = mergeObj_(cur.followUp || {}, (patch && patch.followUp) || {});
  if (typeof patch?.status !== 'undefined') cur.followUp.status = patch.status;
  if (cur.followUp && typeof cur.followUp.enabled === 'undefined') cur.followUp.enabled = true;

  row[ix.idxPayloads[0]] = JSON.stringify(cur);
  s.getRange(hit,1,1,ix.width).setValues([row]);
  return { success:true, updated:true, row: hit };
}

function list_(opts) {
  const s = sh_();
  let ix = ensureRemarkCols_(s, headerIx_(s));
  const last = s.getLastRow();
  if (last <= 1) return compat_({ ok: true, data: [], total: 0 });
  const rows = s.getRange(2,1,last-1,ix.width).getValues();

  const wantBranchKey = norm_(String((opts && opts.branch) || ''));
  const wantExecKey = norm_(String((opts && opts.executive) || ''));
  const wantService = String((opts && opts.service) || '').toLowerCase();
  const wantStatus = String((opts && opts.status) || '').toLowerCase();
  const q = String((opts && opts.q) || '').trim();

  const startMs = (opts && typeof opts.startMs === 'number') ? opts.startMs : null;
  const endMs = (opts && typeof opts.endMs === 'number') ? opts.endMs : null;
  const sinceISO = (opts && opts.sinceISO) ? String(opts.sinceISO) : '';
  const untilISO = (opts && opts.untilISO) ? String(opts.untilISO) : '';

  const page = Math.max(parseInt((opts && opts.page) || '1', 10) || 1, 1);
  const pageSize = Math.min(100, Math.max(0, parseInt((opts && opts.pageSize) || '0', 10) || 0));
  const limit = Math.max(parseInt((opts && opts.limit) || '0', 10) || 0, 0);

  const enriched = rows.map((r) => {
    const payload = ix.idxPayloads.length ? safeJson_(r[ix.idxPayloads[0]]) : null;

    const t = r[ix.idxTime];
    let tsMs = 0;
    if (t instanceof Date) tsMs = t.getTime();
    else if (t) { const d = new Date(String(t)); if (!isNaN(d.getTime())) tsMs = d.getTime(); }

    const rowBranch = String(r[ix.idxBranch] || '').trim();
    const execFromPayload = String((payload && payload.formValues && payload.formValues.executive) || '').trim();
    const branchPayload = String((payload && payload.formValues && payload.formValues.branch) || '').trim();
    const paymentMode = ix.idxPayment >= 0 ? String(r[ix.idxPayment] || '') : '';
    const postAt = (payload && payload.postServiceAt) || (ix.idxPostAt >= 0 ? r[ix.idxPostAt] : '') || '';
    const hasPost = String(postAt || '').trim().length > 0;
    const hasPayments = Array.isArray(payload && payload.payments) && payload.payments.some(function(p){ return Number(p && p.amount || 0) > 0; });
    const hasPaymentMode = String(paymentMode || '').trim().length > 0;
    const amt = ix.idxAmount >= 0 ? r[ix.idxAmount] : '';
    const hasAmount = String(amt || '').trim().length > 0;
    const status = (hasPost || hasPayments || (hasPaymentMode && hasAmount)) ? 'completed' : 'pending';
    const model = payload && payload.formValues ? (payload.formValues.model || '') : '';

    return {
      raw: r,
      payload,
      tsMs,
      name: String(r[ix.idxName] || ''),
      mobile: String(r[ix.idxMobile] || ''),
      regNo: String(r[ix.idxReg] || ''),
      serviceType: String(r[ix.idxSvc] || '').toLowerCase(),
      branchSheet: rowBranch,
      branchPayload,
      executive: execFromPayload,
      paymentMode,
      jcNo: String(r[ix.idxJC] || '').trim(),
      model,
      status
    };
  });

  let filtered = enriched.filter((x) => {
    if (wantBranchKey) {
      const b1 = norm_(x.branchSheet);
      const b2 = norm_(x.branchPayload);
      if (!(b1 === wantBranchKey || b2 === wantBranchKey)) return false;
    }
    if (wantExecKey && norm_(x.executive) !== wantExecKey) return false;
    if (wantService && x.serviceType !== wantService) return false;
    if (wantStatus && x.status !== wantStatus) return false;

    if (startMs && endMs) {
      if (!x.tsMs || x.tsMs < startMs || x.tsMs > endMs) return false;
    } else if (sinceISO || untilISO) {
      const since = sinceISO ? new Date(sinceISO) : null;
      const until = untilISO ? new Date(untilISO) : null;
      if (since && (!x.tsMs || x.tsMs < since.getTime())) return false;
      if (until && (!x.tsMs || x.tsMs > until.getTime())) return false;
    }

    if (q) {
      const hay = [x.name, x.mobile, x.jcNo, x.regNo, x.model, x.branchSheet, x.branchPayload, x.executive, x.paymentMode];
      let hit = false;
      for (var i=0;i<hay.length;i++){ if (norm_(hay[i]).indexOf(norm_(q)) !== -1) { hit = true; break; } }
      if (!hit) return false;
    }
    return true;
  });

  filtered.sort((a,b) => (b.tsMs||0)-(a.tsMs||0));

  const total = filtered.length;
  let slice;
  if (pageSize > 0) {
    const start = (page - 1) * pageSize;
    slice = filtered.slice(start, start + pageSize);
  } else if (limit > 0) {
    const start = (page - 1) * limit;
    slice = filtered.slice(start, start + limit);
  } else {
    slice = filtered;
  }

  ix = headerIx_(s); // refresh in case columns were added above
  const data = slice.map(x => toRowObject_(x.raw, ix));
  return compat_({ ok: true, data, rows: data, total });
}

function compat_(obj) {
  const out = obj || {};
  if (typeof out.success === 'undefined') out.success = true;
  if (!Array.isArray(out.rows) && Array.isArray(out.data)) out.rows = out.data;
  return out;
}

/* ============================
Remarks (Payload.remark + optional columns)
============================ */
function updateRemark_(jcNo, level, text, by) {
  if (!jcNo) return { success:false, message:'jcNo is required' };
  var lv = String(level || '').toLowerCase();
  if (!/(^ok$|^warning$|^alert$)/.test(lv)) return { success:false, message:'level must be ok|warning|alert' };

  var s = sh_();
  var ix = headerIx_(s);
  if (ix.idxJC < 0) return { success:false, message:'JC column not found' };
  if (!ix.idxPayloads.length) return { success:false, message:'Payload column not found' };

  var last = s.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  var rows = s.getRange(2,1,last-1,ix.width).getValues();
  var hit = -1;
  for (var i = rows.length - 1; i >= 0; i--) {
    var jc = String(rows[i][ix.idxJC] || '').trim();
    if (jc === String(jcNo).trim()) { hit = i + 2; break; }
  }
  if (hit < 0) return { success:false, message:'Not found' };

  var row = s.getRange(hit,1,1,ix.width).getValues()[0];
  var payload = safeJson_(row[ix.idxPayloads[0]]) || {};
  var nowIso = new Date().toISOString();
  payload.remark = {
    level: lv,
    text: String(text || '').slice(0, 240),
    by: String(by || '').slice(0, 120),
    at: nowIso
  };
  row[ix.idxPayloads[0]] = JSON.stringify(payload);

  var info = ensureRemarkCols_(s, headerIx_(s));
  var rl = info.idxRemarkLevel;
  var rt = info.idxRemarkText;

  if (rl >= 0) row[rl] = lv.toUpperCase();
  if (rt >= 0) row[rt] = String(text || '').slice(0, 240);

  var width = Math.max(info.width, row.length);
  s.getRange(hit,1,1,width).setValues([row]);

  return { success:true, updated:true, row: hit, jcNo: jcNo, level: lv, text: String(text || '') };
}

/* ============== DAILY COLLECTIONS MODULE (MASTER) ============== */
function dcTodayStrIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');
}
function dcTsIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function dcToNum_(x) {
  const n = Number(x || 0);
  return isNaN(n) ? 0 : n;
}

function dcGetSheet_() {
  const masterId = typeof JOBCARD_DC_MASTER_SPREADSHEET_ID === 'string'
    ? JOBCARD_DC_MASTER_SPREADSHEET_ID
    : '';
  const ss = masterId
    ? openSpreadsheet(masterId)
    : (JOBCARD_SHEET_ID ? openSpreadsheet(JOBCARD_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());

  let sh = ss.getSheetByName(JOBCARD_DC_SHEET);
  if (!sh) sh = ss.insertSheet(JOBCARD_DC_SHEET);

  const w = Math.max(sh.getLastColumn(), JOBCARD_DC_HEADERS.length);
  const first = sh.getRange(1,1,1,w).getValues()[0];
  const lastRow = sh.getLastRow();
  const a1 = String(first[0] || '').trim();
  const looksLikeHint = /^type "@dropdown"/i.test(a1);

  if (lastRow === 0 || (lastRow === 1 && (!a1 || looksLikeHint))) {
    sh.clear();
    sh.getRange(1,1,1,JOBCARD_DC_HEADERS.length).setValues([JOBCARD_DC_HEADERS]);
  }

  return sh;
}

function dcFindCol_(headers, names) {
  // Trim + case-insensitive match for robustness
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  for (var i=0;i<names.length;i++) {
    var j = H.indexOf(norm(names[i]));
    if (j >= 0) return j;
  }
  return -1;
}

function dcIdx_(headers) {
  return {
    Date:   dcFindCol_(headers, ['Date']),
    Branch: dcFindCol_(headers, ['Branch']),
    Staff:  dcFindCol_(headers, ['Staff']),
    Booking: dcFindCol_(headers, ['Booking Amount']),
    JC:      dcFindCol_(headers, ['JC Amount']),
    Minor:   dcFindCol_(headers, ['Minor Sales Amount','Minor Sales Amt']),
    Total:   dcFindCol_(headers, ['Total']),
    Cash:    dcFindCol_(headers, ['Cash Amount']),
    Online:  dcFindCol_(headers, ['Online Amount']),
    TotalCollected: dcFindCol_(headers, ['Total Collected','Total Coln']),
    Opening: dcFindCol_(headers, ['Opening Balance','Opening']),
    Due:     dcFindCol_(headers, ['Due Today','Due']),
    CollectedToday: dcFindCol_(headers, ['Collected Today','Collected']),
    Closing: dcFindCol_(headers, ['Closing Balance','Closing']),
    Done:    dcFindCol_(headers, ['Settlement Done']),
    At:      dcFindCol_(headers, ['Settlement At']),
    UpdatedAt: dcFindCol_(headers, ['Updated At']),
    Notes:   dcFindCol_(headers, ['Notes']),
    Raw:     dcFindCol_(headers, ['Raw Payload']),
    width:   headers.length
  };
}

// Normalize any date cell to 'yyyy-MM-dd' in IST
function dcNormDate_(val) {
  var tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  if (val instanceof Date) return Utilities.formatDate(val, tz, 'yyyy-MM-dd');
  var s = String(val || '');
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  var d = new Date(s);
  if (!isNaN(d.getTime())) return Utilities.formatDate(d, tz, 'yyyy-MM-dd');
  return s;
}
// Derive cash/online from Raw Payload when columns are missing
function dcReadCashOnlineFromRaw_(rawCell) {
  try {
    const raw = JSON.parse(String(rawCell || '{}'));
    if (typeof raw.cash === 'number' || typeof raw.online === 'number') {
      return { cash: Number(raw.cash || 0) || 0, online: Number(raw.online || 0) || 0 };
    }
    const logs = Array.isArray(raw.logs) ? raw.logs : [];
    var c = 0, o = 0;
    for (var i = 0; i < logs.length; i++) {
      c += Number(logs[i] && logs[i].cash || 0) || 0;
      o += Number(logs[i] && logs[i].online || 0) || 0;
    }
    return { cash: c, online: o };
  } catch (_) { return { cash: 0, online: 0 }; }
}

function updateDailyCollection_(branch, staff, amount, type, opt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const amt = dcToNum_(amount);

  const cashInc   = dcToNum_(opt && opt.cashCollected);
  const onlineInc = dcToNum_(opt && opt.onlineCollected);

  if (!b || !s || !(amt > 0)) {
    return { success:false, message:'missing branch/staff or amount<=0' };
  }

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const dateStr = dcTodayStrIndia_();

  const last = sh.getLastRow();
  let hit = -1;

  if (last > 1) {
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      const sameDate = dcNormDate_(r[I.Date]) === dateStr;
      const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
      const sameStaff = String(r[I.Staff] || '').trim().toLowerCase() === s.toLowerCase();
      const notDone = String(r[I.Done] || '').toLowerCase() !== 'true';
      if (sameDate && sameBranch && sameStaff && notDone) {
        hit = i + 2;
        break;
      }
    }
  }

  if (hit < 0) {
    const row = new Array(I.width).fill('');
    row[I.Date] = dateStr;
    row[I.Branch] = b;
    row[I.Staff] = s;

    row[I.Booking] = 0;
    row[I.JC]      = 0;
    row[I.Minor]   = 0;

    if (type === 'booking')         row[I.Booking] = amt;
    else if (type === 'jc')         row[I.JC]      = amt;
    else if (type === 'minorsales') row[I.Minor]   = amt;

    row[I.Total] = dcToNum_(row[I.Booking]) + dcToNum_(row[I.JC]) + dcToNum_(row[I.Minor]);

    if (I.Cash >= 0)   row[I.Cash]   = cashInc;
    if (I.Online >= 0) row[I.Online] = onlineInc;

    row[I.Done]  = false;
    row[I.At]    = '';
    row[I.Raw]   = JSON.stringify({ createdAt: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });

    sh.appendRow(row);
    hit = sh.getLastRow();
  } else {
    const cur = sh.getRange(hit,1,1,I.width).getValues()[0];

    if (type === 'booking')         cur[I.Booking] = dcToNum_(cur[I.Booking]) + amt;
    else if (type === 'jc')         cur[I.JC]      = dcToNum_(cur[I.JC]) + amt;
    else if (type === 'minorsales') cur[I.Minor]   = dcToNum_(cur[I.Minor]) + amt;

    cur[I.Total] = dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]);

    if (I.Cash >= 0)   cur[I.Cash]   = dcToNum_(cur[I.Cash])   + cashInc;
    if (I.Online >= 0) cur[I.Online] = dcToNum_(cur[I.Online]) + onlineInc;
    if (I.TotalCollected >= 0) cur[I.TotalCollected] = (I.Cash>=0?dcToNum_(cur[I.Cash]):0) + (I.Online>=0?dcToNum_(cur[I.Online]):0);

    let raw = {};
    try { raw = JSON.parse(String(cur[I.Raw] || '{}')); } catch (_) {}
    if (!Array.isArray(raw.logs)) raw.logs = [];
    raw.logs.push({ at: dcTsIndia_(), type, amount: amt, cash: cashInc, online: onlineInc });
    cur[I.Raw] = JSON.stringify(raw);

    sh.getRange(hit,1,1,I.width).setValues([cur]);
  }

  // NEW: Append to StaffLedger (non-breaking)
  try {
    staffLedgerAppendFromDailyUpdate_(b, s, amt, type, opt);
  } catch (_){ /* ignore ledger errors to avoid breaking existing flow */ }

  const out = sh.getRange(hit,1,1,I.width).getValues()[0];

  return {
    success:true,
    updatedRow: {
      date: out[I.Date],
      branch: out[I.Branch],
      staff: out[I.Staff],
      booking: dcToNum_(out[I.Booking]),
      jc: dcToNum_(out[I.JC]),
      minor: dcToNum_(out[I.Minor]),
      cashAmount: (I.Cash>=0 ? dcToNum_(out[I.Cash]) : 0),
      onlineAmount: (I.Online>=0 ? dcToNum_(out[I.Online]) : 0),
      total: (I.TotalCollected>=0 ? dcToNum_(out[I.TotalCollected]) : dcToNum_(out[I.Total])),
      settled: String(out[I.Done]).toLowerCase() === 'true',
      settledAt: out[I.At] || ''
    }
  };
}

function settleCollection_(branch, staff, dateOpt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const dateStr = String(dateOpt || dcTodayStrIndia_());

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  let hit = -1;

  for (let i = rows.length - 1; i >= 0; i--) {
    const r = rows[i];
    const sameDate = dcNormDate_(r[I.Date]) === dateStr;
    const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
    const sameStaff = String(r[I.Staff] || '').trim().toLowerCase() === s.toLowerCase();
    const notDone = String(r[I.Done] || '').toLowerCase() !== 'true';
    if (sameDate && sameBranch && sameStaff && notDone) {
      hit = i + 2;
      break;
    }
  }

  if (hit < 0) return { success:false, message:'Not found or already settled' };

  const cur = sh.getRange(hit,1,1,I.width).getValues()[0];
  // Compute closing to block settlement with pending amounts
  const opening = I.Opening>=0 ? dcToNum_(cur[I.Opening]) : 0;
  const due     = I.Due>=0 ? dcToNum_(cur[I.Due]) : (dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]));
  const coll    = I.CollectedToday>=0 ? dcToNum_(cur[I.CollectedToday]) : 0;
  const closing = opening + due - coll;
  if (closing > 0.00001) {
    return { success:false, message:'Cannot settle. Pending amount exists: ' + closing };
  }

  cur[I.Done] = true;
  cur[I.At] = dcTsIndia_();
  sh.getRange(hit,1,1,I.width).setValues([cur]);

  return {
    success:true,
    settled:true,
    row: hit,
    date: cur[I.Date],
    staff: cur[I.Staff],
    branch: cur[I.Branch]
  };
}

function getStaffCollectionSummary_(branch, staff) {
  const bKey = String(branch || '').trim().toLowerCase();
  const sKey = String(staff || '').trim().toLowerCase();
  const today = dcTodayStrIndia_();

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) {
    return { success:true, data: {
      bookingAmountPending:0, jcAmountPending:0, minorSalesAmountPending:0,
      totalPending:0, cashAmountPending:0, onlineAmountPending:0, settlementDone:true
    }};
  }

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  var booking=0, jc=0, minor=0;
  var any = false;
  var latestIdx = -1; var latestTs = 0; var latestRow = null;

  for (var idx = 0; idx < rows.length; idx++) {
    const r = rows[idx];
    const done = String(r[I.Done] || '').toLowerCase() === 'true';
    if (done) continue;

    const sameDate  = dcNormDate_(r[I.Date]) === today;
    const sameBranch= String(r[I.Branch] || '').trim().toLowerCase() === bKey;
    const sameStaff = String(r[I.Staff]  || '').trim().toLowerCase() === sKey;
    if (!(sameDate && sameBranch && sameStaff)) continue;

    any = true;
    booking += dcToNum_(r[I.Booking]);
    jc      += dcToNum_(r[I.JC]);
    minor   += dcToNum_(r[I.Minor]);

    // track latest row by Updated At or fallback to last row order
    var uts = 0;
    if (I.UpdatedAt >= 0) {
      const u = rows[idx][I.UpdatedAt];
      if (u instanceof Date) uts = u.getTime(); else if (u) { var d = new Date(String(u)); if (!isNaN(d.getTime())) uts = d.getTime(); }
    }
    if (uts >= latestTs) { latestTs = uts; latestIdx = idx; latestRow = rows[idx]; }
    if (latestTs === 0) { latestIdx = idx; latestRow = rows[idx]; }
  }

  var collected = 0, cash = 0, online = 0, closingPending = 0;
  if (latestRow) {
    const tot = (I.TotalCollected>=0 ? dcToNum_(latestRow[I.TotalCollected]) : 0) ||
                (I.Total>=0 ? dcToNum_(latestRow[I.Total]) : 0);
    const cashCol = (I.Cash>=0 ? dcToNum_(latestRow[I.Cash]) : 0);
    const onlineCol = (I.Online>=0 ? dcToNum_(latestRow[I.Online]) : 0);
    collected = tot || (I.CollectedToday>=0 ? dcToNum_(latestRow[I.CollectedToday]) : (cashCol + onlineCol));
    cash = cashCol || collected; // if split not available, assume all cash for handover indicator
    online = onlineCol;
    const opening = (I.Opening>=0 ? dcToNum_(latestRow[I.Opening]) : 0);
    const dueSum  = booking + jc + minor;
    const close   = opening + dueSum - collected;
    closingPending = Math.max(0, close);
  }

  return { success:true, data: {
    bookingAmountPending: booking,
    jcAmountPending: jc,
    minorSalesAmountPending: minor,
    totalPending: collected,
    cashAmountPending: cash,
    onlineAmountPending: online,
    bookingAmount: booking, jcAmount: jc, minorSalesAmount: minor,
    total: collected, cashAmount: cash, onlineAmount: online,
    closingPending,
    settlementDone: !any
  }};
}

function collections_(opts) {
  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { ok:true, data:[], total:0 };

  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantDate = String(opts && opts.date || '').trim();
  const page = Math.max(parseInt((opts && opts.page) || '1', 10) || 1, 1);
  const pageSize = Math.min(100, Math.max(0, parseInt((opts && opts.pageSize) || '10',10) || 10));

  function prevClosingFor(dateStr, branch, staff) {
    try {
      let best = '', prev = 0;
      for (let i=0;i<rows.length;i++) {
        const rr = rows[i];
        const d = dcNormDate_(rr[I.Date]);
        if (!d || d >= dateStr) continue;
        if (String(rr[I.Branch]||'').trim().toLowerCase() !== String(branch||'').trim().toLowerCase()) continue;
        if (String(rr[I.Staff]||'').trim().toLowerCase() !== String(staff||'').trim().toLowerCase()) continue;
        if (best === '' || d > best) { best = d; prev = (I.Closing>=0 ? dcToNum_(rr[I.Closing]) : 0); }
      }
      return prev;
    } catch(_) { return 0; }
  }

  const arr = rows.map((r, rowIx) => {
    // Cash/Online robust read
    let cash = 0, online = 0;
    if (I.Cash >= 0 && I.Online >= 0) {
      cash = dcToNum_(r[I.Cash]);
      online = dcToNum_(r[I.Online]);
    } else if (I.Raw >= 0) {
      const x = dcReadCashOnlineFromRaw_(r[I.Raw]);
      cash = x.cash; online = x.online;
    }

    // Base numbers
    const book = dcToNum_(r[I.Booking]);
    const jc   = dcToNum_(r[I.JC]);
    const minor= dcToNum_(r[I.Minor]);
    const derivedDue = book + jc + minor;

    const totalCollectedPref =
      (I.TotalCollected >= 0 ? dcToNum_(r[I.TotalCollected]) : 0) ||
      (I.Total >= 0 ? dcToNum_(r[I.Total]) : 0) ||
      (cash + online);

    // Opening: prefer sheet; fallback to previous closing
    const openingRaw = I.Opening >= 0 ? dcToNum_(r[I.Opening]) : 0;
    let opening = openingRaw;
    if (!opening) {
      opening = prevClosingFor(dcNormDate_(r[I.Date]), r[I.Branch], r[I.Staff]);
    }

    // Due: prefer sheet value when present and > 0; otherwise derive
    let dueToday = I.Due >= 0 ? dcToNum_(r[I.Due]) : 0;
    if (!dueToday) dueToday = derivedDue;

    // Collected: prefer explicit column when > 0; otherwise use totals
    let collToday = I.CollectedToday >= 0 ? dcToNum_(r[I.CollectedToday]) : 0;
    if (!collToday) collToday = totalCollectedPref;

    const closing = opening + dueToday - collToday;

    // Opportunistically write back computed Opening so the sheet stays correct and the UI
    // does not need historical lookbacks. Only write when sheet has 0/blank and we computed > 0.
    try {
      if (I.Opening >= 0 && openingRaw === 0 && opening > 0) {
        sh.getRange(2 + rowIx, 1 + I.Opening).setValue(opening);
      }
    } catch (_) { /* ignore write errors in read path */ }

    return {
      date: dcNormDate_(r[I.Date]),
      branch: r[I.Branch],
      staff: r[I.Staff],
      bookingAmount: book,
      jcAmount: jc,
      minorSalesAmount: minor,
      cashAmount: cash,
      onlineAmount: online,
      total: totalCollectedPref,
      openingBalance: opening,
      dueToday,
      collectedToday: collToday,
      closingBalance: closing,
      settlementDone: String(r[I.Done]).toLowerCase() === 'true',
      settlementAt: r[I.At] || '',
      updatedAt: I.UpdatedAt >= 0 ? (r[I.UpdatedAt] || '') : ''
    };
  }).filter(x => {
    if (wantBranch && String(x.branch || '').trim().toLowerCase() !== wantBranch) return false;
    if (wantDate && String(x.date || '') !== wantDate) return false;
    return true;
  });

  arr.sort((a,b) =>
    String(b.date).localeCompare(String(a.date)) ||
    String(b.settlementAt || '').localeCompare(String(a.settlementAt || ''))
  );

  const total = arr.length;
  const start = (page - 1) * pageSize;
  const data = pageSize > 0 ? arr.slice(start, start + pageSize) : arr;

  return { ok:true, data, total };
}

// Update Opening/Due/Collected/Closing on the same DailyCollections row
function updateCollectionDC_(req) {
  const date = String(req.date || '').trim();
  const branch = String(req.branch || '').trim();
  const staff = String(req.staff || '').trim();
  const collectedToday = dcToNum_(req.collectedToday);
  if (!date || !branch || !staff) return { success:false, message:'date/branch/staff required' };

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const last = sh.getLastRow();

  let hit = -1;
  let rows = [];
  if (last > 1) {
    rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      if (dcNormDate_(r[I.Date]) === date && String(r[I.Branch]||'').trim().toLowerCase() === branch.toLowerCase() && String(r[I.Staff]||'').trim().toLowerCase() === staff.toLowerCase()) {
        hit = i + 2; break;
      }
    }
  }

  if (hit < 0) { // create new
    const row = new Array(I.width).fill('');
    row[I.Date] = date; row[I.Branch] = branch; row[I.Staff] = staff;
    if (I.Opening >= 0) row[I.Opening] = 0;
    if (I.Due >= 0) row[I.Due] = 0;
    if (I.CollectedToday >= 0) row[I.CollectedToday] = collectedToday;
    if (I.Closing >= 0) row[I.Closing] = 0;
    if (I.UpdatedAt >= 0) row[I.UpdatedAt] = dcTsIndia_();
    sh.appendRow(row);
    hit = sh.getLastRow();
    rows = sh.getRange(2,1,hit-1,I.width).getValues();
  }

  const cur = sh.getRange(hit,1,1,I.width).getValues()[0];

  const prevClosing = (function(){
    let prev = 0, best = '';
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== branch.toLowerCase()) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== staff.toLowerCase()) continue;
      const rd = dcNormDate_(r[I.Date]);
      if (!rd || rd >= date) continue;
      if (best === '' || rd > best) { best = rd; prev = (I.Closing>=0 ? dcToNum_(r[I.Closing]) : 0); }
    }
    return prev;
  })();

  const booking = I.Booking>=0 ? dcToNum_(cur[I.Booking]) : 0;
  const jc = I.JC>=0 ? dcToNum_(cur[I.JC]) : 0;
  const minor = I.Minor>=0 ? dcToNum_(cur[I.Minor]) : 0;
  const dueToday = booking + jc + minor;
  const opening = (I.Opening>=0 ? dcToNum_(cur[I.Opening]) : 0) || prevClosing;
  const closing = opening + dueToday - collectedToday;

  if (I.Opening>=0) cur[I.Opening] = opening;
  if (I.Due>=0) cur[I.Due] = dueToday;
  if (I.CollectedToday>=0) cur[I.CollectedToday] = collectedToday;
  if (I.Closing>=0) cur[I.Closing] = closing;
  if (I.TotalCollected>=0) cur[I.TotalCollected] = (I.Cash>=0?dcToNum_(cur[I.Cash]):0) + (I.Online>=0?dcToNum_(cur[I.Online]):0);
  if (I.UpdatedAt>=0) cur[I.UpdatedAt] = dcTsIndia_();

  sh.getRange(hit,1,1,I.width).setValues([cur]);
  return { success:true, row: hit, date, branch, staff, openingBalance: opening, dueToday, collectedToday, closingBalance: closing };
}

/* ============================
   StaffLedger (NEW HELPERS + ENDPOINT LOGIC)
   Sheet: StaffLedger in the same master spreadsheet as DailyCollections
============================ */

const STAFF_LEDGER_SHEET = 'StaffLedger';
const STAFF_LEDGER_HEADERS = [
  'DateTime ISO','Date','Branch','Staff',
  'Source Type','Source ID',
  'Customer Name','Customer Mobile',
  'Payment Mode','Cash Amount','Online Amount','UTR / Ref No',
  'Collected Total','Settled Cash','Settled Online','Settled Total',
  'Settled Flag','Settled At','Settled By','Raw Payload'
];

const STAFF_PREV_DUE_SHEET = 'StaffPrevDue';
const STAFF_PREV_DUE_HEADERS = [
  'Branch','Staff','Amount','Note','Updated By','Updated At','Created At'
];

function slNowIsoIndia_(){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function slDateIndia_(d){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(d || new Date(), tz, 'yyyy-MM-dd');
}

function staffLedgerGetSheet_(){
  const masterId = typeof JOBCARD_DC_MASTER_SPREADSHEET_ID === 'string' ? JOBCARD_DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? openSpreadsheet(masterId) : (JOBCARD_SHEET_ID ? openSpreadsheet(JOBCARD_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());
  let sh = ss.getSheetByName(STAFF_LEDGER_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_LEDGER_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_LEDGER_HEADERS.length).setValues([STAFF_LEDGER_HEADERS]);
  return sh;
}

function staffLedgerIdx_(headers){
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  const find = (name) => H.indexOf(String(name||'').trim().toLowerCase());
  return {
    DateTimeISO: find('datetime iso'),
    Date: find('date'),
    Branch: find('branch'),
    Staff: find('staff'),
    SrcType: find('source type'),
    SrcId: find('source id'),
    CustName: find('customer name'),
    CustMobile: find('customer mobile'),
    PayMode: find('payment mode'),
    Cash: find('cash amount'),
    Online: find('online amount'),
    UTR: find('utr / ref no'),
    Total: find('collected total'),
    SCash: find('settled cash'),
    SOnline: find('settled online'),
    STotal: find('settled total'),
    SFlag: find('settled flag'),
    SAt: find('settled at'),
    SBy: find('settled by'),
    Raw: find('raw payload'),
    width: headers.length
  };
}

function appendStaffLedgerTransaction_(rowObj){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const row = new Array(I.width).fill('');
  const put = (i,v)=>{ if (i>=0) row[i] = (v==null?'':v); };
  put(I.DateTimeISO, rowObj.dateTimeIso || slNowIsoIndia_());
  put(I.Date, rowObj.date || slDateIndia_(new Date()));
  put(I.Branch, rowObj.branch || '');
  put(I.Staff, rowObj.staff || '');
  put(I.SrcType, rowObj.sourceType || '');
  put(I.SrcId, rowObj.sourceId || '');
  put(I.CustName, rowObj.customerName || '');
  put(I.CustMobile, rowObj.customerMobile || '');
  put(I.PayMode, rowObj.paymentMode || '');
  put(I.Cash, Number(rowObj.cashAmount||0)||0);
  put(I.Online, Number(rowObj.onlineAmount||0)||0);
  put(I.UTR, rowObj.utr || '');
  const cash = Number(rowObj.cashAmount||0)||0;
  const online = Number(rowObj.onlineAmount||0)||0;
  put(I.Total, cash + online);
  put(I.SCash, 0);
  put(I.SOnline, 0);
  put(I.STotal, 0);
  put(I.SFlag, false);
  put(I.SAt, '');
  put(I.SBy, '');
  try { put(I.Raw, JSON.stringify(rowObj.rawPayload || {})); } catch(_){ put(I.Raw, ''); }
  sh.appendRow(row);
  return { row: sh.getLastRow() };
}

function staffLedgerAppendFromDailyUpdate_(branch, staff, amount, type, opt){
  try{
    const b = String(branch||'').trim();
    const s = String(staff||'').trim();
    const amt = dcToNum_(amount);
    if (!b || !s || !(amt>0)) return { skipped:true };
    const ctx = (opt && opt.staffLedgerContext) || {};
    let cash = dcToNum_(opt && opt.cashCollected);
    let online = dcToNum_(opt && opt.onlineCollected);

    // Try derive split from ctx.payments if missing
    if (!(cash>0) && !(online>0) && Array.isArray(ctx.payments)){
      try {
        cash = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='cash').reduce((a,p)=>a+(Number(p.amount)||0),0);
        online = ctx.payments.filter(p=>String(p.mode||'').toLowerCase()==='online').reduce((a,p)=>a+(Number(p.amount)||0),0);
      } catch(_) {}
    }
    // Fallback from paymentMode
    if (!(cash>0) && !(online>0)){
      const pm = String(ctx.paymentMode || '').toLowerCase();
      if (pm === 'cash') cash = amt; else if (pm) online = amt; else cash = amt;
    }
    const pmode = (cash>0 && online>0) ? 'mixed' : (cash>0 ? 'cash' : (online>0 ? 'online' : ''));
    // UTR from ctx or payments
    let utr = String(ctx.utr||'').trim();
    if (!utr && Array.isArray(ctx.payments)){
      try {
        const p = ctx.payments.find(p=>String(p.mode||'').toLowerCase()==='online');
        utr = String(p && (p.utr || p.ref || p.reference || p.txnId || p.txn || p.upiRef || '')).trim();
      } catch(_) {}
    }
    const sourceId = String(ctx.sourceId||ctx.jcNo||ctx.bookingId||ctx.orderId||'').trim();
    const mobile10 = String(ctx.customerMobile || ctx.custMobile || '').replace(/\D/g,'').slice(-10);
    let custName = String(ctx.customerName || ctx.custName || '').trim();
    // Fallback: if name missing, try fetch from existing JobCard row by JC or Mobile
    if (!custName && (mobile10 || sourceId)){
      try {
        const found = findExistingRowFull_(mobile10, sourceId);
        if (found){
          const fv = (found.payload && found.payload.formValues) ? found.payload.formValues : {};
          const fromSheet = (found.rowValues && found.ix && found.ix.idxName>=0) ? String(found.rowValues[found.ix.idxName]||'') : '';
          custName = String(fv.custName || fv.customerName || fromSheet || '').trim();
        }
      } catch(_){ /* ignore */ }
    }

    const obj = {
      branch: b,
      staff: s,
      sourceType: String(type||'').toLowerCase(),
      sourceId: sourceId,
      customerName: custName,
      customerMobile: mobile10,
      paymentMode: pmode,
      cashAmount: cash,
      onlineAmount: online,
      utr: utr,
      rawPayload: { from: 'updateDailyCollection_', ctx }
    };
    return appendStaffLedgerTransaction_(obj);
  }catch(err){ return { error: String(err) }; }
}

function staffLedgerRowKey_(row, I){
  const norm = (v) => String(v || '').trim().toLowerCase();
  const cell = (idx) => (idx >= 0 ? row[idx] : '');
  return [
    norm(cell(I.Branch)),
    norm(cell(I.Staff)),
    norm(cell(I.SrcType)),
    norm(cell(I.SrcId)),
    norm(cell(I.CustMobile)),
    norm(cell(I.PayMode)),
    norm(cell(I.Cash)),
    norm(cell(I.Online)),
    norm(cell(I.UTR))
  ].join('|');
}

function staffLedgerRowTs_(row, I){
  const raw = (I.DateTimeISO >= 0 ? row[I.DateTimeISO] : (I.Date >= 0 ? row[I.Date] : ''));
  const t = raw instanceof Date ? raw.getTime() : (new Date(String(raw))).getTime();
  return isFinite(t) ? t : 0;
}

function staffLedgerSummary_(branch, staff){
  const b = String(branch||'').trim().toLowerCase();
  const s = String(staff||'').trim().toLowerCase();
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { success:true, data: { branch:branch, staff:staff, cashPending:0, onlinePending:0, totalPending:0 } };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  const groups = {};
  let lastSettledAt = '';
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    if (String(r[I.Branch]||'').trim().toLowerCase() !== b) continue;
    if (String(r[I.Staff]||'').trim().toLowerCase() !== s) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt = Number(r[I.Online]||0)||0;
    const sc = Number(r[I.SCash]||0)||0;
    const so = Number(r[I.SOnline]||0)||0;
    const key = staffLedgerRowKey_(r, I);
    const g = groups[key];
    if (!g) {
      groups[key] = { cashAmt, onAmt, scMax: sc, soMax: so };
    } else {
      g.scMax = Math.max(g.scMax, sc);
      g.soMax = Math.max(g.soMax, so);
    }
    const sat = r[I.SAt];
    if (sat) { const t = (sat instanceof Date) ? sat.getTime() : (new Date(String(sat))).getTime(); if (isFinite(t)) lastSettledAt = String(sat); }
  }
  let c=0,o=0;
  const keys = Object.keys(groups);
  for (let i=0;i<keys.length;i++){
    const g = groups[keys[i]];
    const cp = Math.max(0, g.cashAmt - g.scMax);
    const op = Math.max(0, g.onAmt - g.soMax);
    if (cp>0 || op>0){ c += cp; o += op; }
  }
  const prevDueRow = staffPrevDueFetch_(branch, staff);
  const prevDueAmt = dcToNum_(prevDueRow && prevDueRow.amount);
  return { success:true, data: {
    branch,
    staff,
    cashPending:c,
    onlinePending:o,
    totalPending:(c+o),
    lastSettledAt,
    prevDueAssigned: prevDueAmt,
    prevDueNote: prevDueRow && prevDueRow.note ? String(prevDueRow.note) : '',
    prevDueUpdatedAt: prevDueRow && prevDueRow.updatedAt ? String(prevDueRow.updatedAt) : '',
    prevDueUpdatedBy: prevDueRow && prevDueRow.updatedBy ? String(prevDueRow.updatedBy) : ''
  } };
}

function staffLedgerTransactions_(branch, staff, mode){
  const m = String(mode||'all').toLowerCase();
  const bKey = String(branch||'').trim().toLowerCase();
  const sKey = String(staff||'').trim().toLowerCase();
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  const out = [];
  if (last > 1){
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    const groups = {};
    for (let i=0;i<rows.length;i++){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== bKey) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== sKey) continue;
      const cashAmt = Number(r[I.Cash]||0)||0;
      const onAmt = Number(r[I.Online]||0)||0;
      const sc = Number(r[I.SCash]||0)||0;
      const so = Number(r[I.SOnline]||0)||0;
      const key = staffLedgerRowKey_(r, I);
      const ts = staffLedgerRowTs_(r, I);
      const g = groups[key];
      if (!g) {
        groups[key] = { row: r, ts, cashAmt, onAmt, scMax: sc, soMax: so };
      } else {
        g.scMax = Math.max(g.scMax, sc);
        g.soMax = Math.max(g.soMax, so);
        if (ts >= g.ts) { g.row = r; g.ts = ts; }
      }
    }
    const keys = Object.keys(groups);
    for (let i=0;i<keys.length;i++){
      const g = groups[keys[i]];
      const cp = Math.max(0, g.cashAmt - g.scMax);
      const op = Math.max(0, g.onAmt - g.soMax);
      const totalPend = cp + op;
      if (!(totalPend>0)) continue;
      if (m==='cash' && !(cp>0)) continue;
      if (m==='online' && !(op>0)) continue;
      const r = g.row;
      out.push({
        dateTimeIso: r[I.DateTimeISO],
        date: r[I.Date],
        sourceType: r[I.SrcType],
        sourceId: r[I.SrcId],
        customerName: r[I.CustName],
        customerMobile: r[I.CustMobile],
        paymentMode: r[I.PayMode],
        cashPending: cp,
        onlinePending: op,
        utr: r[I.UTR]
      });
    }
  }
  return { success:true, rows: out };
}

function ownerLedgerList_(opts){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantStaff  = String(opts && opts.staff  || '').trim().toLowerCase();
  const status     = String(opts && opts.status || 'unsettled').toLowerCase();
  const fromDate   = String(opts && opts.fromDate || '');
  const toDate     = String(opts && opts.toDate || '');
  const rows = (last>1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];
  const within = (d) => {
    const dd = slDateIndia_(d);
    if (fromDate && dd < fromDate) return false;
    if (toDate && dd > toDate) return false;
    return true;
  };
  const out = [];
  for (let i=0;i<rows.length;i++){
    const r = rows[i];
    const b = String(r[I.Branch]||'').trim();
    const s = String(r[I.Staff]||'').trim();
    if (wantBranch && b.toLowerCase() !== wantBranch) continue;
    if (wantStaff && s.toLowerCase() !== wantStaff) continue;
    const d = r[I.Date] || slDateIndia_(r[I.DateTimeISO]||new Date());
    if (!within(d)) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt = Number(r[I.Online]||0)||0;
    const sc = Number(r[I.SCash]||0)||0;
    const so = Number(r[I.SOnline]||0)||0;
    const cp = Math.max(0, cashAmt - sc);
    const op = Math.max(0, onAmt - so);
    const settledFlag = String(r[I.SFlag]||'').toLowerCase()==='true';
    const unsettled = (cp + op) > 0;
    if (status==='unsettled' && !unsettled) continue;
    if (status==='settled' && !settledFlag) continue;
    out.push({
      id: i+2, // actual sheet row index
      dateTimeIso: r[I.DateTimeISO],
      date: d,
      branch: b,
      staff: s,
      sourceType: r[I.SrcType],
      sourceId: r[I.SrcId],
      customerName: r[I.CustName],
      customerMobile: r[I.CustMobile],
      paymentMode: r[I.PayMode],
      cashAmount: cashAmt,
      onlineAmount: onAmt,
      cashPending: cp,
      onlinePending: op,
      utr: r[I.UTR],
      settledFlag: settledFlag,
      settledAt: r[I.SAt] || '',
      settledBy: r[I.SBy] || ''
    });
  }
  return { success:true, rows: out };
}

function staffLedgerSettleRows_(ids, mode, settledBy, scope){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const nowIso = slNowIsoIndia_();
  let updated = 0;
  const idsArr = Array.isArray(ids) ? ids.slice() : [];
  idsArr.sort((a,b)=>a-b);
  for (let k=0;k<idsArr.length;k++){
    const rowIx = idsArr[k];
    if (!Number.isFinite(rowIx) || rowIx < 2) continue;
    const r = sh.getRange(rowIx,1,1,I.width).getValues()[0];
    // Optional scope filter
    if (scope && scope.branch && String(r[I.Branch]||'').trim().toLowerCase() !== String(scope.branch).trim().toLowerCase()) continue;
    if (scope && scope.staff && String(r[I.Staff]||'').trim().toLowerCase() !== String(scope.staff).trim().toLowerCase()) continue;
    const cashAmt = Number(r[I.Cash]||0)||0;
    const onAmt   = Number(r[I.Online]||0)||0;
    let sCash = Number(r[I.SCash]||0)||0;
    let sOn   = Number(r[I.SOnline]||0)||0;
    const m = String(mode||'both').toLowerCase();
    if (m==='cash' || m==='both') sCash = cashAmt;
    if (m==='online' || m==='both') sOn = onAmt;
    const sTot = sCash + sOn;
    const tot = cashAmt + onAmt;
    const flag = (sTot >= tot);
    r[I.SCash] = sCash;
    r[I.SOnline] = sOn;
    r[I.STotal] = sTot;
    r[I.SFlag] = flag;
    if (flag) {
      r[I.SAt] = nowIso;
      r[I.SBy] = String(settledBy||'OWNER');
    }
    sh.getRange(rowIx,1,1,I.width).setValues([r]);
    updated++;
  }
  return { updatedCount: updated };
}

/* ============================
   Staff Previous Due assignments (owner managed)
============================ */
function staffPrevDueGetSheet_(){
  const masterId = typeof JOBCARD_DC_MASTER_SPREADSHEET_ID === 'string' ? JOBCARD_DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? openSpreadsheet(masterId) : (JOBCARD_SHEET_ID ? openSpreadsheet(JOBCARD_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet());
  let sh = ss.getSheetByName(STAFF_PREV_DUE_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_PREV_DUE_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_PREV_DUE_HEADERS.length).setValues([STAFF_PREV_DUE_HEADERS]);
  return sh;
}

function staffPrevDueIdx_(headers){
  const norm = (s) => String(s||'').trim().toLowerCase();
  const H = headers.map(norm);
  const find = (name) => H.indexOf(norm(name));
  return {
    Branch: find('branch'),
    Staff: find('staff'),
    Amount: find('amount'),
    Note: find('note'),
    UpdatedBy: find('updated by'),
    UpdatedAt: find('updated at'),
    CreatedAt: find('created at'),
    width: headers.length
  };
}

function ownerPrevDueList_(opts){
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = String(opts && opts.branch || '').trim().toLowerCase();
  const wantStaff = String(opts && opts.staff || '').trim().toLowerCase();
  const rows = (last>1) ? sh.getRange(2,1,last-1,I.width).getValues() : [];
  const list = [];
  rows.forEach((r, idx) => {
    const branch = String(r[I.Branch]||'').trim();
    const staff = String(r[I.Staff]||'').trim();
    if (wantBranch && branch.toLowerCase() !== wantBranch) return;
    if (wantStaff && staff.toLowerCase() !== wantStaff) return;
    list.push({
      id: idx + 2,
      branch,
      staff,
      amount: dcToNum_(r[I.Amount]),
      note: r[I.Note] || '',
      updatedBy: r[I.UpdatedBy] || '',
      updatedAt: r[I.UpdatedAt] || '',
      createdAt: r[I.CreatedAt] || ''
    });
  });
  list.sort((a,b) => String(b.updatedAt||'').localeCompare(String(a.updatedAt||'')));
  return { success:true, rows: list };
}

function ownerPrevDueSet_(branch, staff, amount, note, updatedBy){
  const b = String(branch||'').trim();
  const s = String(staff||'').trim();
  if (!b || !s) return { success:false, message:'branch and staff required' };
  const amountProvided = !(amount == null || (typeof amount === 'string' && String(amount).trim() === ''));
  if (!amountProvided) return { success:false, message:'amount is required' };
  const amt = Math.max(0, dcToNum_(amount));
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  const wantBranch = b.toLowerCase();
  const wantStaff = s.toLowerCase();
  let hit = -1;
  if (last > 1){
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i=rows.length-1;i>=0;i--){
      const r = rows[i];
      if (String(r[I.Branch]||'').trim().toLowerCase() !== wantBranch) continue;
      if (String(r[I.Staff]||'').trim().toLowerCase() !== wantStaff) continue;
      hit = i + 2;
      break;
    }
  }
  const nowIso = dcTsIndia_();
  if (hit > 0){
    const row = sh.getRange(hit,1,1,I.width).getValues()[0];
    if (I.Branch>=0) row[I.Branch] = b;
    if (I.Staff>=0) row[I.Staff] = s;
    if (I.Amount>=0) row[I.Amount] = amt;
    if (I.Note>=0) row[I.Note] = note || '';
    if (I.UpdatedBy>=0) row[I.UpdatedBy] = updatedBy || '';
    if (I.UpdatedAt>=0) row[I.UpdatedAt] = nowIso;
    sh.getRange(hit,1,1,I.width).setValues([row]);
    return { success:true, updated:true, row: hit, branch:b, staff:s, amount: amt };
  }
  const row = new Array(I.width).fill('');
  if (I.Branch>=0) row[I.Branch] = b;
  if (I.Staff>=0) row[I.Staff] = s;
  if (I.Amount>=0) row[I.Amount] = amt;
  if (I.Note>=0) row[I.Note] = note || '';
  if (I.UpdatedBy>=0) row[I.UpdatedBy] = updatedBy || '';
  if (I.UpdatedAt>=0) row[I.UpdatedAt] = nowIso;
  if (I.CreatedAt>=0) row[I.CreatedAt] = nowIso;
  sh.appendRow(row);
  return { success:true, created:true, row: sh.getLastRow(), branch:b, staff:s, amount: amt };
}

function staffPrevDueFetch_(branch, staff){
  const b = String(branch||'').trim().toLowerCase();
  const s = String(staff||'').trim().toLowerCase();
  if (!b || !s) return { branch: branch||'', staff: staff||'', amount:0 };
  const sh = staffPrevDueGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_PREV_DUE_HEADERS.length)).getValues()[0];
  const I = staffPrevDueIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return { branch: branch||'', staff: staff||'', amount:0 };
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  for (let i = rows.length - 1; i >= 0; i--) {
    const r = rows[i];
    if (String(r[I.Branch]||'').trim().toLowerCase() !== b) continue;
    if (String(r[I.Staff]||'').trim().toLowerCase() !== s) continue;
    return {
      branch: r[I.Branch] || '',
      staff: r[I.Staff] || '',
      amount: dcToNum_(r[I.Amount]),
      note: r[I.Note] || '',
      updatedBy: r[I.UpdatedBy] || '',
      updatedAt: r[I.UpdatedAt] || '',
      createdAt: r[I.CreatedAt] || '',
      row: i + 2
    };
  }
  return { branch: branch||'', staff: staff||'', amount:0 };
}
__MODULES__.jobcard = { doGet, doPost };
})();

(() => {
// ====== MINORSALES =====
function doGet() {
  return ContentService
    .createTextOutput(JSON.stringify({ ok: true, service: 'MinorSales GAS', time: new Date().toISOString() }))
    .setMimeType(ContentService.MimeType.JSON);
}

/**
 * Minor Sales Web App ‚Äì Save cart items (one row per item) with Order ID.
 * Frontend sends:
 * {
 *   action: 'minor_sales_save',
 *   data: {
 *     staffName, branchName, dateTimeIso, orderId,
 *     summaryTotal, purchased: true,
 *     items: [{ item, qty, unitPrice, amount }, ...],
 *     customer: { name, mobile, paymentMode, utr? },
 *     cashCollected?, onlineCollected? // optional split (frontend)
 *   }
 * }
 */

/* Optional: protect your endpoint */
const MINORSALES_WRITE_SECRET = ''; // set and require via payload.secret if you want

const MINORSALES_SHEET_NAME = 'MinorSales';
const MINORSALES_HEADERS = [
  'Order ID','DateTime ISO','Staff','Branch',
  'Items','Qty','Unit','Amount','Total','Purchased',
  'Customer Name','Customer Mobile','Payment Mode','UTR / Reference',
  'Items JSON'
];

/* ============== DAILY COLLECTIONS (JC / Booking / Minor Sales) ============== */

// üëá Master DailyCollections spreadsheet ‚Äì SAME as JC script
const MINORSALES_DC_MASTER_SPREADSHEET_ID = MASTER_SPREADSHEET_ID;

const MINORSALES_DC_SHEET = 'DailyCollections';
const MINORSALES_DC_HEADERS = [
  'Date','Branch','Staff',
  'Booking Amount','JC Amount','Minor Sales Amount',
  'Total', // legacy total
  'Cash Amount','Online Amount','Total Collected',
  'Opening Balance','Due Today','Collected Today','Closing Balance',
  'Settlement Done','Settlement At','Updated At','Notes','Raw Payload'
];

function dcTodayStrIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, 'yyyy-MM-dd');
}

function dcTsIndia_() {
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}

function dcToNum_(x) {
  const n = Number(x || 0);
  return isNaN(n) ? 0 : n;
}

// üëá ALWAYS open the MASTER file, handle "@dropdown" hint row, ensure headers
function dcGetSheet_() {
  const masterId = typeof MINORSALES_DC_MASTER_SPREADSHEET_ID === 'string'
    ? MINORSALES_DC_MASTER_SPREADSHEET_ID
    : '';
  const ss = masterId
    ? openSpreadsheet(masterId)
    : SpreadsheetApp.getActiveSpreadsheet();

  let sh = ss.getSheetByName(MINORSALES_DC_SHEET);
  if (!sh) sh = ss.insertSheet(MINORSALES_DC_SHEET);

  const w = Math.max(sh.getLastColumn(), MINORSALES_DC_HEADERS.length);
  const first = (w > 0) ? sh.getRange(1,1,1,w).getValues()[0] : [];
  const lastRow = sh.getLastRow();
  const a1 = String(first[0] || '').trim();
  const looksLikeHint = /^type "@dropdown"/i.test(a1);

  // If sheet is empty OR only has hint row, reset to headers
  if (lastRow === 0 || (lastRow === 1 && (!a1 || looksLikeHint))) {
    sh.clear();
    sh.getRange(1,1,1,MINORSALES_DC_HEADERS.length).setValues([MINORSALES_DC_HEADERS]);
  }

  return sh;
}

/** ‚úÖ Tolerant column finder */
function findCol_(headers, candidates) {
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  for (var i = 0; i < candidates.length; i++) {
    const want = String(candidates[i]||'').trim().toLowerCase();
    var idx = H.indexOf(want);
    if (idx >= 0) return idx;
  }
  return -1;
}

/** ‚úÖ Tolerant dcIdx_ (works with "Minor Sales Amount" or "Minor Sales Amt") */
function dcIdx_(headers) {
  return {
    Date:   findCol_(headers, ['Date']),
    Branch: findCol_(headers, ['Branch']),
    Staff:  findCol_(headers, ['Staff']),

    Booking: findCol_(headers, ['Booking Amount']),
    JC:      findCol_(headers, ['JC Amount']),
    Minor:   findCol_(headers, ['Minor Sales Amount', 'Minor Sales Amt']),

    Total:   findCol_(headers, ['Total']),
    Cash:    findCol_(headers, ['Cash Amount']),
    Online:  findCol_(headers, ['Online Amount']),
    TotalCollected: findCol_(headers, ['Total Collected']),
    Opening: findCol_(headers, ['Opening Balance']),
    Due:     findCol_(headers, ['Due Today']),
    CollectedToday: findCol_(headers, ['Collected Today']),
    Closing: findCol_(headers, ['Closing Balance']),

    Done:    findCol_(headers, ['Settlement Done']),
    At:      findCol_(headers, ['Settlement At']),
    UpdatedAt: findCol_(headers, ['Updated At']),
    Raw:     findCol_(headers, ['Raw Payload']),
    width:   headers.length
  };
}

// Normalize value to yyyy-MM-dd in IST
function dcNormDate_(val) {
  var tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  if (val instanceof Date) return Utilities.formatDate(val, tz, 'yyyy-MM-dd');
  var s = String(val || '');
  if (/^\d{4}-\d{2}-\d{2}$/.test(s)) return s;
  var d = new Date(s);
  if (!isNaN(d.getTime())) return Utilities.formatDate(d, tz, 'yyyy-MM-dd');
  return s;
}

/**
 * updateDailyCollection_(branch, staff, amount, type, opt?)
 * type = 'booking' | 'jc' | 'minorsales'
 * opt = { cashCollected?: number, onlineCollected?: number }
 */
function updateDailyCollection_(branch, staff, amount, type, opt) {
  const b = String(branch || '').trim();
  const s = String(staff || '').trim();
  const amt = dcToNum_(amount);

  // cash / online split (can be 0)
  const cashInc   = dcToNum_(opt && opt.cashCollected);
  const onlineInc = dcToNum_(opt && opt.onlineCollected);
  const sourceId = opt && opt.sourceId ? String(opt.sourceId) : '';

  if (!b || !s || !(amt > 0)) {
    return { success:false, message:'missing branch/staff or amount<=0' };
  }

  if (sourceId && staffLedgerHasSourceId_(b, s, type, sourceId)) {
    return { success:true, skipped:true, reason:'duplicate sourceId' };
  }

  const sh = dcGetSheet_();
  const headers = sh.getRange(1,1,1,sh.getLastColumn()).getValues()[0];
  const I = dcIdx_(headers);
  const dateStr = dcTodayStrIndia_();

  const last = sh.getLastRow();
  let hit = -1;

  // Find existing unsettled row for same Date + Branch + Staff
  if (last > 1) {
    const rows = sh.getRange(2,1,last-1,I.width).getValues();
    for (let i = rows.length - 1; i >= 0; i--) {
      const r = rows[i];
      const sameDate   = dcNormDate_(r[I.Date]) === dateStr;
      const sameBranch = String(r[I.Branch] || '').trim().toLowerCase() === b.toLowerCase();
      const sameStaff  = String(r[I.Staff]  || '').trim().toLowerCase() === s.toLowerCase();
      const notDone    = String(r[I.Done]   || '').toLowerCase() !== 'true';
      if (sameDate && sameBranch && sameStaff && notDone) {
        hit = i + 2;
        break;
      }
    }
  }

  if (hit < 0) {
    // Create new row
    const row = new Array(I.width).fill('');
    row[I.Date]   = dateStr;
    row[I.Branch] = b;
    row[I.Staff]  = s;

    row[I.Booking] = 0;
    row[I.JC]      = 0;
    row[I.Minor]   = 0;

    if (type === 'booking')         row[I.Booking] = amt;
    else if (type === 'jc')         row[I.JC]      = amt;
    else if (type === 'minorsales') row[I.Minor]   = amt;

    // store split
    if (I.Cash >= 0)   row[I.Cash]   = cashInc;
    if (I.Online >= 0) row[I.Online] = onlineInc;

    row[I.Total] = dcToNum_(row[I.Booking]) + dcToNum_(row[I.JC]) + dcToNum_(row[I.Minor]);
    if (I.TotalCollected >= 0) row[I.TotalCollected] = dcToNum_(row[I.Cash]) + dcToNum_(row[I.Online]);
    row[I.Done]  = false;
    row[I.At]    = '';
    row[I.Raw]   = JSON.stringify({
      createdAt: dcTsIndia_(),
      type,
      amount: amt,
      cash: cashInc,
      online: onlineInc,
      sourceIds: opt && opt.sourceId ? [String(opt.sourceId)] : []
    });

    sh.appendRow(row);
    hit = sh.getLastRow();
  } else {
    // Update existing row
    const cur = sh.getRange(hit,1,1,I.width).getValues()[0];
    let raw = {};
    try { raw = JSON.parse(String(cur[I.Raw] || '{}')); } catch (_) {}
    const sourceId = opt && opt.sourceId ? String(opt.sourceId) : '';
    const existingIds = Array.isArray(raw.sourceIds) ? raw.sourceIds.map(String) : [];
    if (sourceId && existingIds.indexOf(sourceId) >= 0) {
      return { success: true, skipped: true, reason: 'duplicate sourceId' };
    }

    if (type === 'booking')         cur[I.Booking] = dcToNum_(cur[I.Booking]) + amt;
    else if (type === 'jc')         cur[I.JC]      = dcToNum_(cur[I.JC]) + amt;
    else if (type === 'minorsales') cur[I.Minor]   = dcToNum_(cur[I.Minor]) + amt;

    // increment split
    if (I.Cash >= 0)   cur[I.Cash]   = dcToNum_(cur[I.Cash])   + cashInc;
    if (I.Online >= 0) cur[I.Online] = dcToNum_(cur[I.Online]) + onlineInc;

    cur[I.Total] = dcToNum_(cur[I.Booking]) + dcToNum_(cur[I.JC]) + dcToNum_(cur[I.Minor]);
    if (I.TotalCollected >= 0) cur[I.TotalCollected] = dcToNum_(cur[I.Cash]) + dcToNum_(cur[I.Online]);

    if (!Array.isArray(raw.logs)) raw.logs = [];
    raw.logs.push({
      at: dcTsIndia_(),
      type,
      amount: amt,
      cash: cashInc,
      online: onlineInc,
      sourceId: sourceId
    });
    if (sourceId) {
      if (!Array.isArray(raw.sourceIds)) raw.sourceIds = [];
      if (raw.sourceIds.indexOf(sourceId) < 0) raw.sourceIds.push(sourceId);
    }
    cur[I.Raw] = JSON.stringify(raw);

    sh.getRange(hit,1,1,I.width).setValues([cur]);
  }

  const outRow = sh.getRange(hit,1,1,I.width).getValues()[0];
  // NEW: Append to StaffLedger (non-breaking)
  try {
    staffLedgerAppendFromDailyUpdate_(b, s, amt, type, opt);
  } catch (_){ /* ignore ledger errors */ }

  return {
    success:true,
    updatedRow: {
      date:   outRow[I.Date],
      branch: outRow[I.Branch],
      staff:  outRow[I.Staff],
      booking: dcToNum_(outRow[I.Booking]),
      jc:      dcToNum_(outRow[I.JC]),
      minor:   dcToNum_(outRow[I.Minor]),
      cashAmount:   (I.Cash >= 0 ? dcToNum_(outRow[I.Cash]) : 0),
      onlineAmount: (I.Online >= 0 ? dcToNum_(outRow[I.Online]) : 0),
      total:   dcToNum_(outRow[I.Total]),
      settled: String(outRow[I.Done]).toLowerCase() === 'true',
      settledAt: outRow[I.At] || ''
    }
  };
}

/* ============== MAIN MinorSales doPost ============== */

function doPost(e) {
  try {
    if (!e || !e.postData) return out({ success: false, error: 'No postData' }, 400);

    var raw = String(e.postData.contents || '');
    if (!raw) return out({ success: false, error: 'Empty body' }, 400);

    var payload;
    try { payload = JSON.parse(raw); }
    catch (err) { return out({ success: false, error: 'Invalid JSON' }, 400); }

    // Optional secret check
    if (MINORSALES_WRITE_SECRET) {
      var bodySecret = String(payload && payload.secret || '');
      if (bodySecret !== MINORSALES_WRITE_SECRET) return out({ success: false, error: 'unauthorized' }, 401);
    }

    var action = String(payload && payload.action || '').toLowerCase();
    var data = payload && payload.data || null;

    if (action !== 'minor_sales_save' || !data) {
      return out({ success: false, error: 'Unsupported action or missing data' }, 400);
    }

    // Extract / normalize
    var orderId = String(data.orderId || '').trim();
    if (!orderId) orderId = genOrderId();

    var staffName   = u(data.staffName);
    var branchName  = u(data.branchName);
    var dateTimeIso = String(data.dateTimeIso || new Date().toISOString());
    var summaryTotal = num(data.summaryTotal);
    var purchased   = Boolean(data.purchased !== false); // default true
    var items       = Array.isArray(data.items) ? data.items : [];

    if (!items.length) {
      return out({ success: false, error: 'No items provided' }, 400);
    }

    // ‚úÖ fallback if summaryTotal missing/0
    if (!(summaryTotal > 0)) {
      summaryTotal = items.reduce(function(sum, it){
        return sum + (Number(it && it.amount || 0));
      }, 0);
    }

    var cust       = data.customer || {};
    var custName   = u(cust.name || '');
    var custMobile = mobile10(cust.mobile || '');
    var payMode    = u(cust.paymentMode || '');
    var utr        = String(cust.utr || '').trim();

    var sh = getOrCreateSheet(MINORSALES_SHEET_NAME);
    ensureHeaders(sh, MINORSALES_HEADERS);

    // Build a single summary row for all items
    var itemSummary = items.map(function(it){
      var name = u(it && it.item || '');
      var qty = num(it && it.qty);
      if (!(qty > 0)) qty = 1;
      var unit = num(it && it.unitPrice);
      var amount = (it && (it.amount != null)) ? num(it.amount) : (qty * unit);
      return name + ' x' + qty + ' @' + unit + ' = ' + amount;
    }).join(' | ');

    var totalQty = items.reduce(function(sum, it){
      var q = num(it && it.qty);
      if (!(q > 0)) q = 1;
      return sum + q;
    }, 0);

    var row = [
      orderId,
      dateTimeIso,
      staffName, branchName,
      itemSummary, totalQty, '', summaryTotal, summaryTotal,
      purchased,
      custName, custMobile, payMode, utr || '',
      JSON.stringify(items)
    ];

    // Overwrite existing row with same Order ID to prevent duplicates
    var existingRow = findRowByOrderId_(sh, orderId);
    if (existingRow > 0) {
      sh.getRange(existingRow, 1, 1, MINORSALES_HEADERS.length).setValues([row]);
    } else {
      sh.appendRow(row);
    }

    // üî¥ ALSO UPDATE DailyCollections: Minor Sales Amount with Cash/Online split
    try {
      if (purchased && branchName && staffName && summaryTotal > 0) {
        // Prefer explicit split from frontend if present
        var cashCollected   = num(data.cashCollected);
        var onlineCollected = num(data.onlineCollected);

        // If frontend didn't send split, derive from paymentMode
        if (!(cashCollected > 0) && !(onlineCollected > 0)) {
          var pm = String(payMode || '').toLowerCase();
          if (pm === 'cash') {
            cashCollected = summaryTotal;
          } else if (pm) {
            onlineCollected = summaryTotal;
          } else {
            // fallback: treat as cash
            cashCollected = summaryTotal;
          }
        }

        const ledgerCtx = {
          sourceType: 'minorsales',
          sourceId: orderId,
          orderId: orderId,
          customerName: custName,
          customerMobile: custMobile,
          paymentMode: String(payMode||'').toLowerCase(),
          utr: utr || ''
        };
        updateDailyCollection_(branchName, staffName, summaryTotal, 'minorsales', {
          cashCollected:   cashCollected,
          onlineCollected: onlineCollected,
          staffLedgerContext: ledgerCtx,
          sourceId: orderId
        });
      }
    } catch (errDC) {
      // Don't break main response if DailyCollections fails
    }

    return out({ success: true, inserted: items.length, orderId: orderId }, 200);
  } catch (err) {
    return out({ success: false, error: String(err && err.message || err) }, 500);
  }
}

/* ========== Helpers ========== */

function out(obj, _status) {
  return ContentService
    .createTextOutput(JSON.stringify(obj || {}))
    .setMimeType(ContentService.MimeType.JSON);
}

function getOrCreateSheet(name) {
  var ss = SpreadsheetApp.getActive();
  var sh = ss.getSheetByName(name);
  if (!sh) sh = ss.insertSheet(name);
  return sh;
}

function ensureHeaders(sh, headers) {
  var width = headers.length;
  var firstRow = sh.getRange(1, 1, 1, width).getValues()[0] || [];
  var empty = firstRow.every(function(v){ return String(v || '').trim() === ''; });
  var mismatch = headers.some(function(h, i){ return firstRow[i] !== h; });
  if (empty || mismatch) {
    sh.getRange(1, 1, 1, width).setValues([headers]);
    sh.setFrozenRows(1);
  }
}

function u(s) { return String(s || '').trim().toUpperCase(); }

function num(x) {
  var n = Number(x || 0);
  return isNaN(n) ? 0 : n;
}

function mobile10(raw) {
  return String(raw || '').replace(/\D/g, '').slice(-10);
}

function genOrderId() {
  var dt = new Date();
  var yy = String(dt.getFullYear()).slice(-2);
  var mm = ('0' + (dt.getMonth() + 1)).slice(-2);
  var dd = ('0' + dt.getDate()).slice(-2);
  var rand = Math.random().toString(36).slice(2, 6).toUpperCase();
  return yy + mm + dd + '-' + rand;
}

// Find an existing MinorSales row by Order ID (case-insensitive)
function findRowByOrderId_(sh, orderId) {
  var oid = String(orderId || '').trim().toLowerCase();
  if (!oid) return -1;
  var last = sh.getLastRow();
  if (last < 2) return -1;
  var range = sh.getRange(2, 1, last - 1, 1).getValues();
  for (var i = 0; i < range.length; i++) {
    var v = String(range[i][0] || '').trim().toLowerCase();
    if (v && v === oid) return i + 2;
  }
  return -1;
}

/* ============================
   StaffLedger (NEW HELPERS)
============================ */
const STAFF_LEDGER_SHEET = 'StaffLedger';
const STAFF_LEDGER_HEADERS = [
  'DateTime ISO','Date','Branch','Staff',
  'Source Type','Source ID',
  'Customer Name','Customer Mobile',
  'Payment Mode','Cash Amount','Online Amount','UTR / Ref No',
  'Collected Total','Settled Cash','Settled Online','Settled Total',
  'Settled Flag','Settled At','Settled By','Raw Payload'
];

function slNowIsoIndia_(){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(new Date(), tz, "yyyy-MM-dd'T'HH:mm:ss.SSSXXX");
}
function slDateIndia_(d){
  const tz = Session.getScriptTimeZone() || 'Asia/Kolkata';
  return Utilities.formatDate(d || new Date(), tz, 'yyyy-MM-dd');
}

function staffLedgerGetSheet_(){
  const masterId = typeof MINORSALES_DC_MASTER_SPREADSHEET_ID === 'string' ? MINORSALES_DC_MASTER_SPREADSHEET_ID : '';
  const ss = masterId ? openSpreadsheet(masterId) : SpreadsheetApp.getActiveSpreadsheet();
  let sh = ss.getSheetByName(STAFF_LEDGER_SHEET);
  if (!sh) sh = ss.insertSheet(STAFF_LEDGER_SHEET);
  const width = Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length);
  const first = width ? sh.getRange(1,1,1,width).getValues()[0] : [];
  const hasAny = first.some(v => String(v||'').trim().length);
  if (!hasAny) sh.getRange(1,1,1,STAFF_LEDGER_HEADERS.length).setValues([STAFF_LEDGER_HEADERS]);
  return sh;
}

function staffLedgerIdx_(headers){
  const H = headers.map(h => String(h||'').trim().toLowerCase());
  const find = (name) => H.indexOf(String(name||'').trim().toLowerCase());
  return {
    DateTimeISO: find('datetime iso'),
    Date: find('date'),
    Branch: find('branch'),
    Staff: find('staff'),
    SrcType: find('source type'),
    SrcId: find('source id'),
    CustName: find('customer name'),
    CustMobile: find('customer mobile'),
    PayMode: find('payment mode'),
    Cash: find('cash amount'),
    Online: find('online amount'),
    UTR: find('utr / ref no'),
    Total: find('collected total'),
    SCash: find('settled cash'),
    SOnline: find('settled online'),
    STotal: find('settled total'),
    SFlag: find('settled flag'),
    SAt: find('settled at'),
    SBy: find('settled by'),
    Raw: find('raw payload'),
    width: headers.length
  };
}

function appendStaffLedgerTransaction_(rowObj){
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const row = new Array(I.width).fill('');
  const put = (i,v)=>{ if (i>=0) row[i] = (v==null?'':v); };
  put(I.DateTimeISO, rowObj.dateTimeIso || slNowIsoIndia_());
  put(I.Date, rowObj.date || slDateIndia_(new Date()));
  put(I.Branch, rowObj.branch || '');
  put(I.Staff, rowObj.staff || '');
  put(I.SrcType, rowObj.sourceType || '');
  put(I.SrcId, rowObj.sourceId || '');
  put(I.CustName, rowObj.customerName || '');
  put(I.CustMobile, rowObj.customerMobile || '');
  put(I.PayMode, rowObj.paymentMode || '');
  put(I.Cash, Number(rowObj.cashAmount||0)||0);
  put(I.Online, Number(rowObj.onlineAmount||0)||0);
  put(I.UTR, rowObj.utr || '');
  const cash = Number(rowObj.cashAmount||0)||0;
  const online = Number(rowObj.onlineAmount||0)||0;
  put(I.Total, cash + online);
  put(I.SCash, 0);
  put(I.SOnline, 0);
  put(I.STotal, 0);
  put(I.SFlag, false);
  put(I.SAt, '');
  put(I.SBy, '');
  try { put(I.Raw, JSON.stringify(rowObj.rawPayload || {})); } catch(_){ put(I.Raw, ''); }
  sh.appendRow(row);
  return { row: sh.getLastRow() };
}

function staffLedgerHasSourceId_(branch, staff, sourceType, sourceId){
  const bKey = String(branch || '').trim().toLowerCase();
  const sKey = String(staff || '').trim().toLowerCase();
  const tKey = String(sourceType || '').trim().toLowerCase();
  const idKey = String(sourceId || '').trim().toLowerCase();
  if (!bKey || !sKey || !tKey || !idKey) return false;
  const sh = staffLedgerGetSheet_();
  const headers = sh.getRange(1,1,1,Math.max(sh.getLastColumn(), STAFF_LEDGER_HEADERS.length)).getValues()[0];
  const I = staffLedgerIdx_(headers);
  const last = sh.getLastRow();
  if (last <= 1) return false;
  const rows = sh.getRange(2,1,last-1,I.width).getValues();
  for (let i = 0; i < rows.length; i++) {
    const r = rows[i];
    if (String(r[I.Branch]||'').trim().toLowerCase() !== bKey) continue;
    if (String(r[I.Staff]||'').trim().toLowerCase() !== sKey) continue;
    if (String(r[I.SrcType]||'').trim().toLowerCase() !== tKey) continue;
    if (String(r[I.SrcId]||'').trim().toLowerCase() !== idKey) continue;
    return true;
  }
  return false;
}

function staffLedgerAppendFromDailyUpdate_(branch, staff, amount, type, opt){
  try{
    const b = String(branch||'').trim();
    const s = String(staff||'').trim();
    const amt = num(amount);
    if (!b || !s || !(amt>0)) return { skipped:true };
    const ctx = (opt && opt.staffLedgerContext) || {};
    let cash = num(opt && opt.cashCollected);
    let online = num(opt && opt.onlineCollected);
    if (!(cash>0) && !(online>0)){
      const pm = String(ctx.paymentMode || '').toLowerCase();
      if (pm === 'cash') cash = amt; else if (pm) online = amt; else cash = amt;
    }
    const pmode = (cash>0 && online>0) ? 'mixed' : (cash>0 ? 'cash' : (online>0 ? 'online' : ''));
    const obj = {
      branch: b,
      staff: s,
      sourceType: String(type||'').toLowerCase(),
      sourceId: String(ctx.sourceId||ctx.orderId||'').trim(),
      customerName: ctx.customerName || '',
      customerMobile: String(ctx.customerMobile || '').replace(/\D/g,'').slice(-10),
      paymentMode: pmode,
      cashAmount: cash,
      onlineAmount: online,
      utr: String(ctx.utr||'').trim(),
      rawPayload: { from: 'updateDailyCollection_', ctx }
    };
    return appendStaffLedgerTransaction_(obj);
  }catch(err){ return { error: String(err) }; }
}
__MODULES__.minorsales = { doGet, doPost };
})();

(() => {
// ====== QUOTATION =====
function doGet(e) {
  try {
    const p = e && e.parameter ? e.parameter : {};
    const action = String(p.action || '').toLowerCase();

    if (action === 'nextserial') {
      return json_({ success: true, nextSerial: nextSerial_() });
    }

    if (action === 'search') {
      const mode = p.mode || 'serial';
      const query = p.query || '';
      return json_({ success: true, rows: search_(mode, query) });
    }

    if (action === 'followups') {
      const filter = p.filter || 'today';
      const branch = String(p.branch || '').trim();
      const executive = String(p.executive || '').trim(); // optional
      return json_({ success: true, rows: followups_(filter, branch, executive) });
    }

    if (action === 'list') {
      // Pagination + filters (compatible with legacy limit)
      const limit = parseInt(p.limit || '0', 10) || 0; // legacy: optional
      const branch = String(p.branch || '').trim();
      const mode = String(p.mode || '').trim().toLowerCase();

      const page = Math.max(1, parseInt(p.page || '1', 10) || 1);
      const pageSize = Math.min(100, Math.max(1, parseInt(p.pageSize || p.pagesize || '10', 10) || 10));

      const q = String(p.q || '').trim();
      const status = String(p.status || '').trim().toLowerCase();
      const start = p.start ? +p.start : null; // epoch ms
      const end = p.end ? +p.end : null;       // epoch ms

      const resp = list_({ page, pageSize, limit, branch, mode, q, status, start, end });
      return json_({ ok: true, success: true, data: resp.data, rows: resp.data, total: resp.total });
    }

    return json_({ ok: true, hint: 'Use ?action=list, ?action=nextSerial, ?action=search or ?action=followups' });
  } catch (err) {
    return json_({ success: false, error: String(err) });
  }
}

function doPost(e) {
  try {
    const body = e.postData && e.postData.contents ? JSON.parse(e.postData.contents) : {};
    const action = String(body.action || '').toLowerCase();

    if (action === 'save') {
      const data = body.data || body;
      return json_(saveQuotation_(data));
    }

    if (action === 'search') {
      return json_({ success: true, rows: search_(body.mode || 'serial', body.query || '') });
    }

    if (action === 'updatefollowup') {
      return json_({ success: true, ...(updateFollowup_(body.serialNo, body.patch || {})) });
    }

    if (action === 'list') {
      const limit = parseInt(body.limit || '0', 10) || 0; // legacy
      const branch = String(body.branch || '').trim();
      const mode = String(body.mode || '').trim().toLowerCase();

      const page = Math.max(1, parseInt(body.page || '1', 10) || 1);
      const pageSize = Math.min(100, Math.max(1, parseInt(body.pageSize || body.pagesize || '10', 10) || 10));

      const q = String(body.q || '').trim();
      const status = String(body.status || '').trim().toLowerCase();
      const start = body.start ? +body.start : null; // epoch ms
      const end = body.end ? +body.end : null;       // epoch ms

      const resp = list_({ page, pageSize, limit, branch, mode, q, status, start, end });
      return json_({ ok: true, success: true, data: resp.data, rows: resp.data, total: resp.total });
    }

    // Upsert a short remark into dedicated columns + Payload.remark
    if (action === 'remark') {
      const serialNo = String(body.serialNo || '').trim();
      const level = String(body.level || '').toLowerCase(); // ok|warning|alert
      const text  = String(body.text || '').trim();
      const by    = String(body.by || '').trim(); // optional
      return json_(updateRemark_(serialNo, level, text, by));
    }

    return json_({ success: false, message: 'Unknown action' });
  } catch (err) {
    return json_({ success: false, error: String(err) });
  }
}

/**
 * Quotation Web App (no-duplicate upsert by Quotation_ID) with dedicated remark columns.
 */
const QUOTATION_SHEET_ID = ''; // leave '' if bound to the target Sheet
const QUOTATION_SHEET_NAME = 'Quotations'; // change to your tab name

// Preferred headers (tolerate variations when reading/writing)
const QUOTATION_HEADERS = [
  'Timestamp','Customer_Name','Mobile','Company','Model','Variant',
  'Remarks','Payload','Branch','Executive_Name','Quotation_ID',
  'RemarkLevel','RemarkText'
];

// When upserting and multiple duplicates exist, update the newest and optionally delete older ones
const DEDUPE_ON_UPDATE = true;

// ---------- Helpers ----------
function getSheet_() {
  const ss = QUOTATION_SHEET_ID ? openSpreadsheet(QUOTATION_SHEET_ID) : SpreadsheetApp.getActiveSpreadsheet();
  return ensureSheetWithHeader(ss, QUOTATION_SHEET_NAME, QUOTATION_HEADERS);
}

function json_(obj) {
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function safeJson_(txt, def) {
  try { return JSON.parse(String(txt || '')); } catch (e) { return def; }
}
function toTenDigits_(s) { return String(s||'').replace(/\D/g,'').replace(/^0+/,'').slice(-10); }
function startOfDay_(d) { const x = new Date(d); x.setHours(0,0,0,0); return x; }
function endOfDay_(d) { const x = new Date(d); x.setHours(23,59,59,999); return x; }

function norm_(s) { return String(s || '').trim().toLowerCase(); }
function contains_(h, n) { return norm_(h).indexOf(norm_(n)) !== -1; }

// Read the current header row as strings
function headerRow_(sh) {
  const width = Math.max(sh.getLastColumn(), QUOTATION_HEADERS.length);
  const vals = sh.getRange(1,1,1,width).getValues()[0];
  return vals.map(v => String(v || '').trim());
}

// Tolerant header index finder: exact, then underscore/space normalized, then regex
function headerIndex_(headers, want, rxAlt) {
  const norm = s => String(s || '').trim().toLowerCase().replace(/[\s_]+/g, '_');
  const t = norm(want);
  let idx = headers.findIndex(h => norm(h) === t);
  if (idx >= 0) return idx + 1;
  if (rxAlt) {
    idx = headers.findIndex(h => rxAlt.test(String(h || '')));
    if (idx >= 0) return idx + 1;
  }
  return 0;
}

function idxTimestamp_(headers) { return headerIndex_(headers, 'Timestamp'); }
function idxCustomer_(headers) { return headerIndex_(headers, 'Customer_Name', /customer/i); }
function idxMobile_(headers) { return headerIndex_(headers, 'Mobile', /mobile/i); }
function idxCompany_(headers) { return headerIndex_(headers, 'Company', /company/i); }
function idxModel_(headers) { return headerIndex_(headers, 'Model', /\bmodel\b/i); }
function idxVariant_(headers) { return headerIndex_(headers, 'Variant', /\bvariant\b/i); }
function idxRemarks_(headers) { return headerIndex_(headers, 'Remarks', /remarks?/i); }
function idxPayload_(headers) { return headerIndex_(headers, 'Payload', /payload/i); }
function idxBranch_(headers) { return headerIndex_(headers, 'Branch', /branch/i); }
function idxExecutive_(headers) { return headerIndex_(headers, 'Executive_Name', /executive/i); }
function idxSerial_(headers) { return headerIndex_(headers, 'Quotation_ID', /(quotation[_\s]id|quotation\s(no|number)|serial(\s*no)?|booking[_\s]*(id|no))/i); }
// Optional remark columns (auto-created on first write)
function idxRemarkLevel_(headers) { return headerIndex_(headers, 'RemarkLevel', /remark.*level/i); }
function idxRemarkText_(headers) { return headerIndex_(headers, 'RemarkText', /remark.*text/i); }

// ---------- Serial (numeric fallback only) ----------
function nextSerial_() {
  const sh = getSheet_();
  const headers = headerRow_(sh);
  const c = idxSerial_(headers);
  if (!c) return '1';
  const last = sh.getLastRow();
  if (last <= 1) return '1';
  const vals = sh.getRange(2, c, last-1, 1).getValues()
    .map(r => parseInt(String(r[0]).trim(), 10))
    .filter(n => Number.isFinite(n));
  const max = vals.length ? Math.max.apply(null, vals) : 0;
  return String(max + 1);
}

// ---------- Find rows by Quotation_ID (exact match, trimmed) ----------
function findRowsBySerial_(serial) {
  if (!serial) return [];
  const sh = getSheet_();
  const headers = headerRow_(sh);
  const c = idxSerial_(headers);
  if (!c) return [];
  const last = sh.getLastRow();
  if (last <= 1) return [];
  const vals = sh.getRange(2, c, last - 1, 1).getValues();
  const q = String(serial).trim();
  const rows = [];
  for (let i = 0; i < vals.length; i++) {
    if (String(vals[i][0]).trim() === q) rows.push(i + 2);
  }
  return rows;
}

// ---------- Save (UPSERT by Quotation_ID) with Lock ----------
function saveQuotation_(data) {
  const lock = LockService.getDocumentLock();
  lock.waitLock(15000);
  try {
    const sh = getSheet_();
    const headers = headerRow_(sh);

    const fv = data.formValues || {};
    const payload = data.payload || {};

    // Prefer client-provided serial (e.g., Q-<BRANCH>-XXXXXX). Fallback to numeric.
    let serial = String(
      (data.serialNo != null ? data.serialNo : (fv.serialNo != null ? fv.serialNo : ''))
    ).trim();
    if (!serial) serial = nextSerial_();

    // Resolve column indices (tolerant)
    const cTs   = idxTimestamp_(headers);
    const cName = idxCustomer_(headers);
    const cMob  = idxMobile_(headers);
    const cComp = idxCompany_(headers);
    const cMod  = idxModel_(headers);
    const cVar  = idxVariant_(headers);
    const cRem  = idxRemarks_(headers);
    const cPay  = idxPayload_(headers);
    const cBr   = idxBranch_(headers);
    const cEx   = idxExecutive_(headers);
    const cSer  = idxSerial_(headers);
    if (!cSer) return { success:false, message:'Quotation_ID column not found' };

    const now = new Date();
    const values = {
      [cTs]: now,
      [cName]: fv.name || '',
      [cMob]: fv.mobile || '',
      [cComp]: fv.company || '',
      [cMod]: fv.bikeModel || '',
      [cVar]: fv.variant || '',
      [cRem]: fv.remarks || '',
      [cPay]: JSON.stringify(payload),
      [cBr]:  fv.branch || '',
      [cEx]:  fv.executive || '',
      [cSer]: serial,
    };

    const matches = findRowsBySerial_(serial);

    if (matches.length > 0) {
      const targetRow = Math.max.apply(null, matches);
      // Update only the columns we control
      Object.keys(values).forEach(c => {
        const col = Number(c);
        if (col > 0) sh.getRange(targetRow, col).setValue(values[c]);
      });

      if (DEDUPE_ON_UPDATE && matches.length > 1) {
        const toDelete = matches.filter(r => r !== targetRow).sort((a,b) => b - a);
        toDelete.forEach(r => sh.deleteRow(r));
      }

      return { success:true, updated:true, serialNo:serial, row:targetRow };
    } else {
      // Append a new row, writing only our columns
      const newRow = sh.getLastRow() + 1;
      if (newRow === 1) sh.getRange(1,1,1,QUOTATION_HEADERS.length).setValues([QUOTATION_HEADERS]);
      Object.keys(values).forEach(c => {
        const col = Number(c);
        if (col > 0) sh.getRange(newRow, col).setValue(values[c]);
      });
      return { success:true, created:true, serialNo:serial, row:newRow };
    }
  } finally {
    try { lock.releaseLock(); } catch (e) {}
  }
}

// ---------- Search (serial or mobile) ----------
function search_(mode, query) {
  const sh = getSheet_();
  const last = sh.getLastRow();
  if (last <= 1) return [];

  const headers = headerRow_(sh);
  const width = Math.min(sh.getLastColumn(), Math.max(headers.length, QUOTATION_HEADERS.length));
  const data = sh.getRange(2,1,last-1,width).getValues();

  const idxSerial = idxSerial_(headers) - 1;
  const idxMobile = idxMobile_(headers) - 1;
  const idxPayload = idxPayload_(headers) - 1;

  const q = String(query || '').trim();
  const ten = toTenDigits_(q);
  const modeMobile = String(mode||'serial').toLowerCase() === 'mobile';

  const rows = data
    .map((r, i) => ({ row: i+2, r }))
    .filter(({ r }) => {
      if (modeMobile) {
        const m = toTenDigits_(r[idxMobile]);
        return ten ? (m && (m.endsWith(ten))) : false;
      } else {
        return String(r[idxSerial] || '').trim() === q;
      }
    })
    .sort((a,b) => b.row - a.row)
    .slice(0, 50)
    .map(({row, r}) => {
      const payload = safeJson_(r[idxPayload], null);
      const pickCell = (rx) => {
        const j = headers.findIndex(h => rx.test(String(h||'')));
        return j >= 0 ? r[j] : '';
      };
      return {
        row,
        payload,
        values: {
          serialNo: r[idxSerial],
          name: pickCell(/customer/i),
          mobile: r[idxMobile],
          company: pickCell(/company/i),
          bikeModel: pickCell(/\bmodel\b/i),
          variant: pickCell(/\bvariant\b/i),
          branch: pickCell(/branch/i),
          executive: pickCell(/executive/i),
        }
      };
    });

  return rows;
}

// ---------- Follow-ups list (strict branch filter; executive optional) ----------
function followups_(filter, branch, executive) {
  const sh = getSheet_();
  const last = sh.getLastRow();
  if (last <= 1) return [];

  const headers = headerRow_(sh);
  const width = Math.min(sh.getLastColumn(), Math.max(headers.length, QUOTATION_HEADERS.length));
  const data = sh.getRange(2,1,last-1,width).getValues();

  const idxSerial = idxSerial_(headers) - 1;
  const idxPayload = idxPayload_(headers) - 1;
  const idxBranch = idxBranch_(headers) - 1;
  const idxExec = idxExecutive_(headers) - 1;

  const today = new Date();
  const start = startOfDay_(today);
  const end = endOfDay_(today);
  const want = String(filter || 'today').toLowerCase();
  const wantBranchKey = norm_(branch);
  const wantExecKey = norm_(executive); // applied only if non-empty

  const out = [];

  for (let i = 0; i < data.length; i++) {
    const r = data[i];
    const payload = safeJson_(r[idxPayload], null);
    if (!payload || !payload.followUp) continue;

    const fu = payload.followUp || {};
    const status = String(fu.status || 'pending').toLowerCase();
    if (status !== 'pending') continue;
    if (!fu.enabled && fu.enabled !== undefined) continue;

    const at = fu.at ? new Date(fu.at) : null;

    // Resolve branch/executive from payload first, then cells
    const rowBranch = String(
      fu.branch ||
      (payload.formValues && payload.formValues.branch) ||
      (idxBranch >= 0 ? r[idxBranch] : '') ||
      ''
    ).trim();
    const rowExec = String(
      (payload.formValues && payload.formValues.executive) ||
      fu.assignedTo ||
      (idxExec >= 0 ? r[idxExec] : '') ||
      ''
    ).trim();

    // STRICT BRANCH FILTER
    if (wantBranchKey && norm_(rowBranch) !== wantBranchKey) continue;
    // Optional executive filter
    if (wantExecKey && norm_(rowExec) !== wantExecKey) continue;

    let keep = true;
    if (want !== 'all') {
      if (!at || isNaN(at.getTime())) keep = false;
      else if (want === 'today')    keep = (at >= start && at <= end);
      else if (want === 'overdue')  keep = (at < start);
      else if (want === 'upcoming') keep = (at > end);
    }
    if (!keep) continue;

    out.push({ row: i + 2, payload, values: { serialNo: r[idxSerial], branch: rowBranch, executive: rowExec } });
  }

  out.sort((a,b) => b.row - a.row);
  return out;
}

// ---------- Update follow-up ----------
function updateFollowup_(serialNo, patch) {
  if (!serialNo) return { success:false, message:'serialNo is required' };
  const sh = getSheet_();
  const last = sh.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  const headers = headerRow_(sh);
  const cSerial = idxSerial_(headers);
  const cPayload = idxPayload_(headers);
  if (!cSerial || !cPayload) return { success:false, message:'Required columns not found' };

  let targetRow = -1;
  const vals = sh.getRange(2, cSerial, last-1, 1).getValues();
  for (let i = 0; i < vals.length; i++) {
    if (String(vals[i][0]).trim() === String(serialNo).trim()) { targetRow = i + 2; break; }
  }
  if (targetRow < 0) return { success:false, message:'Quotation not found' };

  const cell = sh.getRange(targetRow, cPayload).getValue();
  const payload = safeJson_(cell, {}) || {};
  const fu = payload.followUp || {};
  const patchObj = (patch && typeof patch === 'object') ? patch : null;

  if (patchObj) {
    if (patchObj.followUp && typeof patchObj.followUp === 'object') {
      const src = patchObj.followUp;
      if ('at' in src) fu.at = src.at;
      if ('notes' in src) fu.notes = src.notes;
      if ('assignedTo' in src) fu.assignedTo = src.assignedTo;
      if ('branch' in src) fu.branch = src.branch;
      if ('enabled' in src) fu.enabled = !!src.enabled;
      if ('status' in src) fu.status = String(src.status || '').toLowerCase() || 'pending';
    }
    if ('status' in patchObj) fu.status = String(patchObj.status || '').toLowerCase() || 'pending';
    if ('closeReason' in patchObj) payload.closeReason = patchObj.closeReason;
    if ('closeNotes' in patchObj) payload.closeNotes = patchObj.closeNotes;
    if ('closedAt' in patchObj) payload.closedAt = patchObj.closedAt;
    if ('purchasedElsewhere' in patchObj) payload.purchasedElsewhere = patchObj.purchasedElsewhere;
    if ('notes' in patchObj) payload.notes = patchObj.notes;
    if ('followupNotes' in patchObj) payload.followupNotes = patchObj.followupNotes;
    if ('remarks' in patchObj) payload.remarks = patchObj.remarks;
  }
  if (!('status' in fu)) fu.status = 'pending';
  if (!('enabled' in fu)) fu.enabled = true;

  payload.followUp = fu;
  sh.getRange(targetRow, cPayload).setValue(JSON.stringify(payload));

  return { success:true, row: targetRow, serialNo, followUp: fu };
}

// ---------- List Quotations (paginated + filters) ----------
function list_({ page = 1, pageSize = 10, limit = 0, branch = '', mode = '', q = '', status = '', start = null, end = null } = {}) {
  const sh = getSheet_();
  const last = sh.getLastRow();
  if (last <= 1) return { data: [], total: 0 };

  const headers = headerRow_(sh);
  const width = Math.min(sh.getLastColumn(), Math.max(headers.length, QUOTATION_HEADERS.length));
  const rows = sh.getRange(2, 1, last - 1, width).getValues();

  const cTs = idxTimestamp_(headers) - 1;
  const cName = idxCustomer_(headers) - 1;
  const cMob = idxMobile_(headers) - 1;
  const cComp = idxCompany_(headers) - 1;
  const cMod = idxModel_(headers) - 1;
  const cVar = idxVariant_(headers) - 1;
  const cPay = idxPayload_(headers) - 1;
  const cBr = idxBranch_(headers) - 1;
  const cEx = idxExecutive_(headers) - 1;
  const cSer = idxSerial_(headers) - 1;
  const cRL = idxRemarkLevel_(headers) - 1; // may be -1 if not present
  const cRT = idxRemarkText_(headers) - 1; // may be -1 if not present

  const wantBranchKey = norm_((branch || ''));
  const wantMode = String(mode || '').toLowerCase();
  const wantStatus = String(status || '').toLowerCase();
  const wantQ = String(q || '').trim();

  const enriched = rows.map((r) => {
    const payload = safeJson_(cPay >= 0 ? r[cPay] : '', null) || null;
    const fv = (payload && payload.formValues) || {};

    const ts = cTs >= 0 ? r[cTs] : '';
    let tsMs = 0;
    if (ts instanceof Date) tsMs = ts.getTime();
    else if (ts) {
      const d = new Date(ts);
      if (!isNaN(d.getTime())) tsMs = d.getTime();
    }

    // Remark: prefer dedicated columns; fallback to payload.remark
    const pr = payload && payload.remark ? payload.remark : null;
    const levelFromCols = cRL >= 0 ? r[cRL] : '';
    const textFromCols = cRT >= 0 ? r[cRT] : '';
    const level = levelFromCols || (pr && pr.level) || '';
    const text  = textFromCols  || (pr && pr.text)  || '';

    const rowBranchRaw = fv.branch || (cBr >= 0 ? String(r[cBr] || '') : '');
    const execName = fv.executive || (cEx >= 0 ? r[cEx] : '');
    const modeRaw = (payload && payload.mode) ? String(payload.mode).toLowerCase() : '';
    const followUpStatus = payload && payload.followUp && payload.followUp.status ? String(payload.followUp.status).toLowerCase() : '';

    return {
      tsMs,
      values: {
        Timestamp:        cTs  >= 0 ? r[cTs]  : '',
        Customer_Name:    cName>= 0 ? r[cName]: (fv.name || ''),
        Mobile:           cMob >= 0 ? r[cMob] : (fv.mobile || ''),
        Company:          cComp>= 0 ? r[cComp]: (fv.company || ''),
        Model:            cMod >= 0 ? r[cMod] : (fv.bikeModel || fv.model || ''),
        Variant:          cVar >= 0 ? r[cVar] : (fv.variant || ''),
        Branch:           rowBranchRaw,
        Executive_Name:   execName,
        'Quotation No.':  cSer >= 0 ? r[cSer] : (fv.serialNo || ''),
        Payload:          cPay >= 0 ? r[cPay] : '',
        RemarkLevel:      level || '',
        RemarkText:       text  || '',
      },
      payload,
      rowBranchRaw,
      execName,
      modeRaw,
      followUpStatus,
      name: cName>=0 ? r[cName] : (fv.name || ''),
      mobile: cMob>=0 ? r[cMob] : (fv.mobile || ''),
      serial: cSer>=0 ? r[cSer] : (fv.serialNo || ''),
      company: cComp>=0 ? r[cComp] : (fv.company || ''),
      model: cMod>=0 ? r[cMod] : (fv.bikeModel || fv.model || ''),
      variant: cVar>=0 ? r[cVar] : (fv.variant || ''),
    };
  });

  // Filters
  let filtered = enriched.filter((x) => {
    if (wantBranchKey && norm_(x.rowBranchRaw) !== wantBranchKey) return false;
    if (wantMode && x.modeRaw !== wantMode) return false;
    if (wantStatus && x.followUpStatus !== wantStatus) return false;
    if (start && end) {
      if (!x.tsMs || x.tsMs < start || x.tsMs > end) return false;
    }
    if (wantQ) {
      const hay = [
        x.name, x.mobile, x.serial, x.company, x.model, x.variant,
        x.rowBranchRaw, x.execName
      ];
      let hit = false;
      for (var i=0;i<hay.length;i++) {
        if (contains_(hay[i], wantQ)) { hit = true; break; }
      }
      if (!hit) return false;
    }
    return true;
  });

  // Sort newest first
  filtered.sort((a,b) => (b.tsMs||0) - (a.tsMs||0));

  const total = filtered.length;

  // Legacy limit support (if limit > 0 and page not set by caller)
  let dataSlice;
  if (limit > 0 && (page === 1 && pageSize === 10 && !q && !status && !start && !end)) {
    dataSlice = filtered.slice(0, limit);
  } else {
    const startIdx = (page - 1) * pageSize;
    dataSlice = filtered.slice(startIdx, startIdx + pageSize);
  }

  const data = dataSlice.map(x => ({ values: x.values, payload: x.payload }));
  return { data, total };
}

// ---------- Upsert remark into Payload + dedicated columns ----------
function updateRemark_(serialNo, level, text, by) {
  if (!serialNo) return { success:false, message:'serialNo is required' };
  const lv = String(level || '').toLowerCase();
  if (!/(^ok$|^warning$|^alert$)/.test(lv)) return { success:false, message:'level must be ok|warning|alert' };

  const sh = getSheet_();
  const last = sh.getLastRow();
  if (last <= 1) return { success:false, message:'No data' };

  // Ensure remark columns exist
  let headers = headerRow_(sh);
  let rl = idxRemarkLevel_(headers);
  let rt = idxRemarkText_(headers);
  if (!rl) {
    rl = headers.length + 1;
    sh.getRange(1, rl).setValue('RemarkLevel');
    headers = headerRow_(sh);
  }
  if (!rt) {
    rt = Math.max(sh.getLastColumn(), headers.length) + 1;
    sh.getRange(1, rt).setValue('RemarkText');
    headers = headerRow_(sh);
  }

  const cSerial = idxSerial_(headers);
  const cPayload = idxPayload_(headers);
  if (!cSerial || !cPayload) return { success:false, message:'Required columns not found' };

  const matches = findRowsBySerial_(serialNo);
  if (!matches.length) return { success:false, message:'Quotation not found' };
  const row = Math.max.apply(null, matches);

  const cell = sh.getRange(row, cPayload).getValue();
  const payload = safeJson_(cell, {}) || {};
  const nowIso = new Date().toISOString();
  payload.remark = {
    level: lv,
    text: String(text || '').slice(0, 240),
    by: String(by || '').slice(0, 120),
    at: nowIso,
  };
  sh.getRange(row, cPayload).setValue(JSON.stringify(payload));

  sh.getRange(row, rl).setValue(lv.toUpperCase());
  sh.getRange(row, rt).setValue(String(text || '').slice(0, 240));

  return { success:true, serialNo, row, level: lv, text };
}
__MODULES__.quotation = { doGet, doPost };
})();

(() => {
// ====== STOCKS =====
// Google Apps Script drop-in for Stock Movements + Current Snapshot
// Mirrors the Node/Mongo logic in server/routes/stocksRoutes.js using two sheets:
//   - StockMovements: immutable-ish movement log (one row per add/transfer/return/invoice)
//   - StockSnapshot: one row per chassis capturing current branch/status
//
// Deploy as a Web App:
//   - Publish ‚Üí Deploy as web app ‚Üí execute as Me ‚Üí allow anyone with the link
//   - doGet/doPost are action-driven (see ACTION SWITCHES below)
//
// Sheet schemas (headers must be on row 1):
// StockMovements headers:
//   movementId, timestamp, chassisNo, company, model, variant, color,
//   action, sourceBranch, sourceBranchKey, targetBranch, targetBranchKey,
//   returnTo, customerName, transferStatus, notes,
//   createdByName, createdById, resolvedByName, resolvedById, resolvedAt,
//   deleted
//
// StockSnapshot headers:
//   chassisNo, company, model, variant, color,
//   sourceBranch, sourceBranchKey, lastSourceBranch,
//   status, lastMovementId, updatedAt

const CONFIG = {
  MOVEMENTS_SHEET: 'StockMovements',
  SNAPSHOT_SHEET: 'StockSnapshot',
  DEFAULT_LIMIT: 500,
  // If this Apps Script is NOT bound to a spreadsheet, set this to your sheet ID.
  // Example: '1AbC...xyz' from https://docs.google.com/spreadsheets/d/<ID>/edit
  SPREADSHEET_ID: '',
};

const MOVEMENT_HEADERS = [
  'movementId', 'timestamp', 'chassisNo', 'company', 'model', 'variant', 'color',
  'action', 'sourceBranch', 'sourceBranchKey', 'targetBranch', 'targetBranchKey',
  'returnTo', 'customerName', 'transferStatus', 'notes',
  'createdByName', 'createdById', 'resolvedByName', 'resolvedById', 'resolvedAt',
  'deleted',
];

const SNAPSHOT_HEADERS = [
  'chassisNo', 'company', 'model', 'variant', 'color',
  'sourceBranch', 'sourceBranchKey', 'lastSourceBranch',
  'status', 'lastMovementId', 'updatedAt',
];

// ---- Entry points ----

function doGet(e) {
  // Make it safe when run from the editor (e can be undefined)
  const params = e && e.parameter ? e.parameter : {};
  const action = String(params.action || 'list').toLowerCase();

  if (action === 'current') return respond(handleCurrent(params));
  if (action === 'pending') return respond(handlePendingTransfers(params));
  return respond(handleList(params));
}

function doPost(e) {
  const body = parseBody(e);
  const queryParams = e && e.parameter ? e.parameter : {};
  const action = String(body.action || queryParams.action || 'create').toLowerCase();

  if (action === 'create') return respond(handleCreate(body));
  if (action === 'admit') return respond(handleAdmitReject(body, 'admitted'));
  if (action === 'reject') return respond(handleAdmitReject(body, 'rejected'));
  if (action === 'update') return respond(handleUpdate(body));
  if (action === 'delete') return respond(handleDelete(body));
  return respond({ ok: false, message: 'Unknown action' });
}

// ---- Core handlers ----

function handleCreate(body) {
  const now = new Date();
  const from = body.data || body || {};
  const movement = {
    movementId: from.movementId || Utilities.getUuid(),
    chassisNo: upper(from.Chassis_No || from.chassisNo || ''),
    company: trim(from.Company || from.company),
    model: trim(from.Model || from.model),
    variant: trim(from.Variant || from.variant),
    color: trim(from.Color || from.color),
    action: (from.Action || from.action || 'transfer').toString().toLowerCase(),
    sourceBranch: trim(from.Source_Branch || from.sourceBranch || ''),
    targetBranch: trim(from.Target_Branch || from.targetBranch || ''),
    returnTo: trim(from.Return_To || from.returnTo || ''),
    customerName: trim(from.Customer_Name || from.customerName || ''),
    transferStatus: 'completed',
    notes: trim(from.Notes || from.notes || ''),
    createdByName: trim(body.createdBy || from.createdByName || ''),
    createdById: trim(from.createdById || ''),
    resolvedByName: '',
    resolvedById: '',
    resolvedAt: '',
    deleted: false,
    timestamp: now.toISOString(),
  };

  if (!movement.chassisNo) return { ok: false, message: 'Chassis number is required' };

  movement.sourceBranchKey = normalizeKey(movement.sourceBranch);
  movement.targetBranchKey = normalizeKey(movement.targetBranch);

  const movements = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS);
  const snapshot = readTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS);
  const currentSnap = snapshot.find((r) => upper(r.chassisNo) === movement.chassisNo && String(r.status || '').toLowerCase() === 'in_stock');

  // Auto-convert ADD to TRANSFER if chassis already in another branch
  if (movement.action === 'add' && currentSnap) {
    if (currentSnap.sourceBranch && currentSnap.sourceBranch !== movement.sourceBranch) {
      movement.action = 'transfer';
      movement.targetBranch = movement.sourceBranch || movement.targetBranch || '';
      movement.targetBranchKey = normalizeKey(movement.targetBranch);
      movement.sourceBranch = currentSnap.sourceBranch;
      movement.sourceBranchKey = normalizeKey(movement.sourceBranch);
      movement.notes = movement.notes ? movement.notes + ' (auto: add‚Üítransfer)' : '(auto: add‚Üítransfer)';
    } else {
      return { ok: false, code: 409, message: 'Chassis already exists in this branch' };
    }
  }

  if (movement.action === 'transfer') {
    if (!movement.targetBranch) return { ok: false, message: 'Target branch is required for transfer' };
    if (movement.sourceBranch && movement.sourceBranch === movement.targetBranch) {
      return { ok: false, message: 'Source and target branch cannot be the same' };
    }
    movement.transferStatus = 'pending';
    const pending = movements.find((m) =>
      !truthy(m.deleted) &&
      lower(m.action) === 'transfer' &&
      lower(m.transferStatus) === 'pending' &&
      upper(m.chassisNo) === movement.chassisNo
    );
    if (pending) return { ok: false, code: 409, message: 'A pending transfer already exists for this chassis' };
  } else {
    movement.transferStatus = 'completed';
  }

  movements.push(movement);
  writeTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS, movements);
  applyMovementToSnapshot(movement);
  return { ok: true, data: movement };
}

function handleAdmitReject(body, nextStatus) {
  const id = trim(body.movementId || body.id || '');
  if (!id) return { ok: false, message: 'movementId is required' };
  const movements = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS);
  const idx = movements.findIndex((m) => m.movementId === id);
  if (idx === -1) return { ok: false, message: 'Transfer not found' };
  const mv = movements[idx];
  if (lower(mv.action) !== 'transfer') return { ok: false, message: 'Not a transfer' };
  if (lower(mv.transferStatus) !== 'pending') return { ok: false, message: 'Transfer already resolved' };
  mv.transferStatus = nextStatus;
  mv.resolvedAt = new Date().toISOString();
  mv.resolvedByName = trim(body.resolvedByName || body.user || '');
  mv.resolvedById = trim(body.resolvedById || '');
  const note = trim(body.notes || body.reason || '');
  if (note) mv.notes = mv.notes ? mv.notes + ' | ' + (nextStatus === 'admitted' ? 'Admit: ' : 'Reject: ') + note : (nextStatus === 'admitted' ? 'Admit: ' : 'Reject: ') + note;
  movements[idx] = mv;
  writeTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS, movements);
  applyMovementToSnapshot(mv);
  return { ok: true, data: mv };
}

function handleUpdate(body) {
  const id = trim(body.movementId || body.id || '');
  if (!id) return { ok: false, message: 'movementId is required' };
  const movements = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS);
  const idx = movements.findIndex((m) => m.movementId === id);
  if (idx === -1) return { ok: false, message: 'Movement not found' };
  const mv = movements[idx];
  const patch = body.data || body.patch || body;
  MOVEMENT_HEADERS.forEach((h) => {
    if (patch[h] !== undefined) mv[h] = patch[h];
  });
  mv.sourceBranchKey = normalizeKey(mv.sourceBranch);
  mv.targetBranchKey = normalizeKey(mv.targetBranch);
  movements[idx] = mv;
  writeTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS, movements);
  recomputeSnapshotForChassis(mv.chassisNo, movements);
  return { ok: true, data: mv };
}

function handleDelete(body) {
  const id = trim(body.movementId || body.id || '');
  if (!id) return { ok: false, message: 'movementId is required' };
  const movements = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS);
  const idx = movements.findIndex((m) => m.movementId === id);
  if (idx === -1) return { ok: false, message: 'Movement not found' };
  movements[idx].deleted = true;
  writeTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS, movements);
  recomputeSnapshotForChassis(movements[idx].chassisNo, movements);
  return { ok: true };
}

function handleList(params) {
  const branch = trim(params.branch || '');
  const mode = lower(params.mode || 'any'); // source|target|any
  const limit = clampInt(params.limit, CONFIG.DEFAULT_LIMIT);
  const page = Math.max(parseInt(params.page || '1', 10), 1);
  const skip = (page - 1) * limit;
  const branchKey = normalizeKey(branch);
  const rows = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS)
    .filter((m) => !truthy(m.deleted))
    .filter((m) => {
      if (!branchKey) return true;
      if (mode === 'source') return normalizeKey(m.sourceBranch) === branchKey;
      if (mode === 'target') return normalizeKey(m.targetBranch) === branchKey;
      return normalizeKey(m.sourceBranch) === branchKey || normalizeKey(m.targetBranch) === branchKey;
    })
    .sort((a, b) => toDate(b.timestamp) - toDate(a.timestamp));
  const paged = rows.slice(skip, skip + limit);
  return { ok: true, total: rows.length, count: paged.length, data: paged };
}

function handleCurrent(params) {
  const branch = trim(params.branch || '');
  const branchKey = normalizeKey(branch);
  const limit = clampInt(params.limit, CONFIG.DEFAULT_LIMIT);
  const page = Math.max(parseInt(params.page || '1', 10), 1);
  const skip = (page - 1) * limit;
  const rows = readTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS)
    .filter((r) => lower(r.status) === 'in_stock')
    .filter((r) => (!branchKey ? true : normalizeKey(r.sourceBranch) === branchKey))
    .sort((a, b) => toDate(b.updatedAt) - toDate(a.updatedAt));
  const paged = rows.slice(skip, skip + limit);
  return { ok: true, total: rows.length, count: paged.length, data: paged };
}

function handlePendingTransfers(params) {
  const branch = trim(params.branch || '');
  const branchKey = normalizeKey(branch);
  const limit = clampInt(params.limit, CONFIG.DEFAULT_LIMIT);
  const rows = readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS)
    .filter((m) => !truthy(m.deleted))
    .filter((m) => lower(m.action) === 'transfer' && lower(m.transferStatus) === 'pending')
    .filter((m) => (!branchKey ? true : normalizeKey(m.targetBranch) === branchKey))
    .sort((a, b) => toDate(a.timestamp) - toDate(b.timestamp))
    .slice(0, limit);
  return { ok: true, count: rows.length, data: rows };
}

// ---- Snapshot logic (mirrors applyMovementToStock + recompute) ----

function applyMovementToSnapshot(movement) {
  const snapshots = readTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS);
  const idx = snapshots.findIndex((s) => upper(s.chassisNo) === upper(movement.chassisNo));
  const act = lower(movement.action);
  const transferStatus = lower(movement.transferStatus || 'completed');
  const transferAdmitted = transferStatus === 'admitted' || transferStatus === 'completed';
  const baseVehicle = {
    company: movement.company || '',
    model: movement.model || '',
    variant: movement.variant || '',
    color: movement.color || '',
  };
  let next = null;

  if (act === 'add') {
    next = {
      ...baseVehicle,
      sourceBranch: movement.sourceBranch || '',
      sourceBranchKey: normalizeKey(movement.sourceBranch),
      lastSourceBranch: '',
      status: 'in_stock',
      lastMovementId: movement.movementId,
      updatedAt: new Date().toISOString(),
    };
  } else if (act === 'transfer') {
    const prev = idx >= 0 ? snapshots[idx] : null;
    const prevBranch = prev?.sourceBranch || movement.sourceBranch || '';
    const stayBranch = movement.sourceBranch || prevBranch;
    const nextBranch = transferAdmitted ? (movement.targetBranch || prevBranch || '') : stayBranch;
    next = {
      ...baseVehicle,
      sourceBranch: nextBranch,
      sourceBranchKey: normalizeKey(nextBranch),
      lastSourceBranch: prevBranch,
      status: 'in_stock',
      lastMovementId: movement.movementId,
      updatedAt: new Date().toISOString(),
    };
  } else if (act === 'return' || act === 'invoice') {
    next = {
      ...baseVehicle,
      sourceBranch: '',
      sourceBranchKey: '',
      lastSourceBranch: movement.sourceBranch || '',
      status: 'out',
      lastMovementId: movement.movementId,
      updatedAt: new Date().toISOString(),
    };
  }

  if (!next) return;
  if (idx >= 0) {
    snapshots[idx] = { ...snapshots[idx], ...next, chassisNo: movement.chassisNo };
  } else {
    snapshots.push({ chassisNo: movement.chassisNo, ...next });
  }
  writeTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS, snapshots);
}

function recomputeSnapshotForChassis(chassisNo, movementsInput) {
  const ch = upper(chassisNo);
  const movements = movementsInput || readTable(CONFIG.MOVEMENTS_SHEET, MOVEMENT_HEADERS);
  const latest = movements
    .filter((m) => upper(m.chassisNo) === ch && !truthy(m.deleted))
    .sort((a, b) => toDate(b.timestamp) - toDate(a.timestamp))[0];
  const snapshots = readTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS);
  const idx = snapshots.findIndex((s) => upper(s.chassisNo) === ch);
  if (!latest) {
    if (idx >= 0) {
      snapshots.splice(idx, 1);
      writeTable(CONFIG.SNAPSHOT_SHEET, SNAPSHOT_HEADERS, snapshots);
    }
    return;
  }
  applyMovementToSnapshot(latest);
}

// ---- Sheet helpers ----

function parseBody(e) {
  if (!e || !e.postData || !e.postData.contents) return {};
  try { return JSON.parse(e.postData.contents); } catch (err) { return {}; }
}

function respond(obj) {
  // TextOutput cannot set headers in Apps Script Web Apps; we rely on Web App CORS settings.
  return ContentService.createTextOutput(JSON.stringify(obj))
    .setMimeType(ContentService.MimeType.JSON);
}

function getSpreadsheet() {
  if (CONFIG.SPREADSHEET_ID) {
    return openSpreadsheet(CONFIG.SPREADSHEET_ID);
  }
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  if (!ss) throw new Error('No active spreadsheet. Set CONFIG.SPREADSHEET_ID.');
  return ss;
}

function getSheet(name) {
  const ss = getSpreadsheet();
  let sh = ss.getSheetByName(name);
  if (!sh) {
    sh = ss.insertSheet(name);
  }
  return sh;
}

function ensureHeaders(sheet, headers) {
  const range = sheet.getRange(1, 1, 1, headers.length);
  const current = range.getValues()[0];
  let changed = false;
  headers.forEach((h, i) => {
    if (current[i] !== h) {
      current[i] = h;
      changed = true;
    }
  });
  if (changed) range.setValues([current]);
}

function readTable(sheetName, headers) {
  const sh = getSheet(sheetName);
  ensureHeaders(sh, headers);
  const values = sh.getDataRange().getValues();
  if (values.length <= 1) return [];
  const head = values[0];
  return values.slice(1).map((row) => {
    const obj = {};
    head.forEach((h, i) => { obj[h] = row[i]; });
    return obj;
  });
}

function writeTable(sheetName, headers, rows) {
  const sh = getSheet(sheetName);
  sh.clearContents();
  ensureHeaders(sh, headers);
  if (!rows || !rows.length) return;
  const data = rows.map((row) => headers.map((h) => row[h] === undefined ? '' : row[h]));
  sh.getRange(2, 1, data.length, headers.length).setValues(data);
}

// ---- Utils ----

function normalizeKey(s) {
  return String(s || '').toLowerCase().normalize('NFKD').replace(/[^a-z0-9]/g, '');
}

function upper(s) { return String(s || '').trim().toUpperCase(); }
function lower(s) { return String(s || '').trim().toLowerCase(); }
function trim(s) { return String(s || '').trim(); }
function truthy(v) { return String(v).toLowerCase() === 'true' || v === true; }
function clampInt(v, max) {
  const n = parseInt(v || CONFIG.DEFAULT_LIMIT, 10);
  if (!Number.isFinite(n) || n <= 0) return CONFIG.DEFAULT_LIMIT;
  return Math.min(n, max || CONFIG.DEFAULT_LIMIT);
}
function toDate(v) {
  const d = new Date(v);
  return Number.isNaN(d.getTime()) ? new Date(0) : d;
}
__MODULES__.stocks = { doGet, doPost };
})();

(() => {
// ====== VEHICLE CATALOG =====
/**
 * Vehicle Catalog Web App (Google Apps Script)
 * Supports list / upsert / delete for Company, Model, Variant, Color, OnRoadPrice, plus audit (UpdatedAt/UpdatedBy).
 *
 * Deploy:
 *  - File > Project properties > copy Script ID for reference.
 *  - Deploy > New deployment > Select type "Web app".
 *  - Execute as: Me (the owner)
 *  - Who has access: Anyone with the link
 *  - After deploy, copy the Web App URL and set it in your client env as VITE_VEHICLE_CATALOG_GAS_URL.
 *
 * Expected sheet layout (first row headers):
 *  Company | Model | Variant | Color | OnRoadPrice | Key | UpdatedAt | UpdatedBy
 */

// Target sheet: https://docs.google.com/spreadsheets/d/1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U/edit?gid=0#gid=0
const CATALOG_SPREADSHEET_ID = '1XSwT6GQiXUsH_zH8VEymsrCfHb1QW_FbdKwMSqnE4_U'; // Sheet ID
const CATALOG_SHEET_NAME = 'Catalog';

function getSheet_() {
  const ss = openSpreadsheet(CATALOG_SPREADSHEET_ID);
  const sheet = ss.getSheetByName(CATALOG_SHEET_NAME) || ss.insertSheet(CATALOG_SHEET_NAME);
  const headers = ['Company', 'Model', 'Variant', 'Color', 'OnRoadPrice', 'Key', 'UpdatedAt', 'UpdatedBy'];
  const width = Math.max(sheet.getLastColumn(), headers.length);
  const firstRow = width ? sheet.getRange(1, 1, 1, width).getValues()[0] : [];
  if (!firstRow.length) {
    sheet.getRange(1, 1, 1, headers.length).setValues([headers]);
    return sheet;
  }
  const norm = (s) => String(s || '').trim().toLowerCase();
  const hasHeader = (h) => firstRow.findIndex((v) => norm(v) === norm(h)) !== -1;
  let updated = false;
  headers.forEach((h) => {
    if (!hasHeader(h)) {
      firstRow.push(h);
      updated = true;
    }
  });
  if (updated) sheet.getRange(1, 1, 1, firstRow.length).setValues([firstRow]);
  return sheet;
}

function buildKey_(obj) {
  const toKey = (s) => String(s || '').trim().toUpperCase();
  return [toKey(obj.Company), toKey(obj.Model), toKey(obj.Variant)].join('|');
}

function readRows_() {
  const sheet = getSheet_();
  const values = sheet.getDataRange().getValues();
  if (values.length <= 1) return [];
  const headers = values[0];
  const rows = [];
  for (let i = 1; i < values.length; i++) {
    const row = values[i];
    const obj = {};
    headers.forEach((h, idx) => { obj[h] = row[idx]; });
    obj._row = i + 1; // 1-based row index in Sheet
    rows.push(obj);
  }
  return rows;
}

function writeRow_(sheet, rowIndex, obj) {
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const row = headers.map((h) => obj[h] ?? '');
  sheet.getRange(rowIndex, 1, 1, headers.length).setValues([row]);
}

function doGet(e) {
  const action = (e && e.parameter && e.parameter.action) ? String(e.parameter.action).toLowerCase() : 'list';
  if (action === 'list') {
    const rows = readRows_();
    return ContentService.createTextOutput(JSON.stringify({ ok: true, rows, count: rows.length })).setMimeType(ContentService.MimeType.JSON);
  }
  return ContentService.createTextOutput(JSON.stringify({ ok: true, message: 'Vehicle Catalog API' })).setMimeType(ContentService.MimeType.JSON);
}

function doPost(e) {
  const payload = parseBody_(e);
  const action = String(payload.action || 'upsert').toLowerCase();
  try {
    if (action === 'delete') {
      return handleDelete_(payload);
    }
    return handleUpsert_(payload);
  } catch (err) {
    return ContentService.createTextOutput(JSON.stringify({ ok: false, message: err.message || String(err) }))
      .setMimeType(ContentService.MimeType.JSON);
  }
}

function handleUpsert_(payload) {
  const sheet = getSheet_();
  const required = ['company', 'model', 'variant'];
  required.forEach((k) => {
    if (!payload[k]) throw new Error('Missing ' + k);
  });
  const colorRaw = payload.color || payload.colors || payload.Color || payload.Colours || '';
  const rec = {
    Company: String(payload.company).trim(),
    Model: String(payload.model).trim(),
    Variant: String(payload.variant).trim(),
    Color: String(colorRaw || '').trim(),
    OnRoadPrice: Number(payload.onRoadPrice || 0) || 0,
    UpdatedBy: payload.updatedBy ? String(payload.updatedBy).trim() : '',
  };
  rec.Key = buildKey_(rec);
  rec.UpdatedAt = new Date();

  const rows = readRows_();
  const lastRow = sheet.getLastRow();
  const lookupKeyRaw = payload.key || payload.previousKey || payload.originalKey || '';
  const targetKey = lookupKeyRaw ? String(lookupKeyRaw).toUpperCase() : rec.Key;
  const rowIdRaw = payload.id || payload.rowId || payload.row || payload._row;
  const rowId = rowIdRaw ? Number(rowIdRaw) : NaN;
  let rowNumber = null;

  if (!isNaN(rowId) && rowId >= 2 && rowId <= lastRow) {
    const rowIdValue = Math.floor(rowId);
    if (!lookupKeyRaw) {
      rowNumber = rowIdValue;
    } else {
      const rowById = rows.find((r) => r._row === rowIdValue);
      if (rowById && buildKey_(rowById) === targetKey) rowNumber = rowIdValue;
    }
  }

  if (!rowNumber) {
    const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
    if (idx >= 0) rowNumber = rows[idx]._row;
  }

  if (rowNumber) {
    writeRow_(sheet, rowNumber, rec);
    return ContentService.createTextOutput(JSON.stringify({ ok: true, updated: true, row: rowNumber, data: rec }))
      .setMimeType(ContentService.MimeType.JSON);
  }

  const nextRow = lastRow + 1;
  writeRow_(sheet, nextRow, rec);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, created: true, row: nextRow, data: rec }))
    .setMimeType(ContentService.MimeType.JSON);
}

function handleDelete_(payload) {
  const sheet = getSheet_();
  const rows = readRows_();
  const targetKey = payload.key ? String(payload.key).toUpperCase() : buildKey_({
    Company: payload.company,
    Model: payload.model,
    Variant: payload.variant,
  });
  const idx = rows.findIndex((r) => buildKey_(r) === targetKey);
  if (idx < 0) throw new Error('Record not found');
  const rowNumber = rows[idx]._row;
  sheet.deleteRow(rowNumber);
  return ContentService.createTextOutput(JSON.stringify({ ok: true, deleted: true, row: rowNumber }))
    .setMimeType(ContentService.MimeType.JSON);
}

function parseBody_(e) {
  if (!e) return {};
  if (e.postData && e.postData.contents) {
    try { return JSON.parse(e.postData.contents); } catch (_) { /* fall through */ }
  }
  if (e.parameter) {
    const obj = {};
    Object.keys(e.parameter).forEach((k) => { obj[k] = e.parameter[k]; });
    return obj;
  }
  return {};
}

// Run once if Colors show prices and OnRoadPrice is 0 (data shifted by one column).
function fixShiftedColumns_() {
  const sheet = getSheet_();
  const headers = sheet.getRange(1, 1, 1, sheet.getLastColumn()).getValues()[0];
  const norm = (s) => String(s || '').trim().toLowerCase();
  const idx = (name) => headers.findIndex((h) => norm(h) === norm(name));
  const colColor = idx('Color');
  const colPrice = idx('OnRoadPrice');
  const colKey = idx('Key');
  const colUpdatedAt = idx('UpdatedAt');
  const colUpdatedBy = idx('UpdatedBy');
  if ([colColor, colPrice, colKey, colUpdatedAt, colUpdatedBy].some((i) => i < 0)) {
    throw new Error('Missing one or more required headers.');
  }
  const lastRow = sheet.getLastRow();
  if (lastRow <= 1) return;
  const range = sheet.getRange(2, 1, lastRow - 1, sheet.getLastColumn());
  const values = range.getValues();
  const isNumericLike = (v) => {
    const s = String(v || '').replace(/[",\s‚Çπ]/g, '');
    return s !== '' && !isNaN(Number(s));
  };
  const looksLikeKey = (v) => String(v || '').includes('|');
  const looksLikeDate = (v) => !isNaN(new Date(v).getTime());
  let changed = false;
  values.forEach((row) => {
    const colorVal = row[colColor];
    const priceVal = row[colPrice];
    const keyVal = row[colKey];
    const updatedAtVal = row[colUpdatedAt];
    const updatedByVal = row[colUpdatedBy];
    const shouldShift =
      isNumericLike(colorVal) &&
      !isNumericLike(priceVal) &&
      looksLikeKey(priceVal) &&
      !updatedByVal &&
      looksLikeDate(keyVal);
    if (!shouldShift) return;
    row[colUpdatedBy] = updatedAtVal;
    row[colUpdatedAt] = keyVal;
    row[colKey] = priceVal;
    row[colPrice] = colorVal;
    row[colColor] = '';
    changed = true;
  });
  if (changed) range.setValues(values);
}
__MODULES__.vehicleCatalog = { doGet, doPost };
})();

const MODULE_ALIAS = {
  booking: 'booking',
  bookings: 'booking',
  branch: 'branches',
  branches: 'branches',
  jobcard: 'jobcard',
  jobcards: 'jobcard',
  minorsales: 'minorsales',
  minor: 'minorsales',
  quotation: 'quotation',
  quotes: 'quotation',
  stock: 'stocks',
  stocks: 'stocks',
  vehiclecatalog: 'vehicleCatalog',
  vehiclecatalogue: 'vehicleCatalog',
  vehiclecatalogs: 'vehicleCatalog',
  catalog: 'vehicleCatalog',
};

function resolveModuleName(e) {
  const params = e && e.parameter ? e.parameter : {};
  const raw = String(params.module || params.Module || params.mod || '').trim().toLowerCase().replace(/[^a-z0-9]/g, '');
  const resolved = MODULE_ALIAS[raw];
  if (resolved) return resolved;
  if (raw) return raw;
  return 'booking';
}

function dispatchToModule(method, e) {
  const moduleName = resolveModuleName(e);
  const module = __MODULES__[moduleName];
  if (!module) {
    return ContentService
      .createTextOutput(JSON.stringify({ success: false, error: `Unknown module: ${moduleName}` }))
      .setMimeType(ContentService.MimeType.JSON);
  }
  const fn = module[method];
  if (typeof fn !== 'function') {
    return ContentService
      .createTextOutput(JSON.stringify({ success: false, error: `Module ${moduleName} does not support ${method}` }))
      .setMimeType(ContentService.MimeType.JSON);
  }
  return fn(e);
}

function doGet(e) {
  return dispatchToModule('doGet', e);
}

function doPost(e) {
  return dispatchToModule('doPost', e);
}

function doOptions(e) {
  return dispatchToModule('doOptions', e);
}
